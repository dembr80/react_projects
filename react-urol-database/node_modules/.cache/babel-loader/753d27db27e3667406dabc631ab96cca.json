{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\dembr\\\\Documents\\\\GitHub\\\\react_projects\\\\react-urol-database\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\dembr\\\\Documents\\\\GitHub\\\\react_projects\\\\react-urol-database\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar Iconv = require('iconv-lite');\n\nvar SMALL_BUFFER_SIZE = 1024;\nvar MEDIUM_BUFFER_SIZE = 16384; //16k\n\nvar LARGE_BUFFER_SIZE = 131072; //128k\n\nvar BIG_BUFFER_SIZE = 1048576; //1M\n\nvar MAX_BUFFER_SIZE = 16777219; //16M + 4\n\n/**\n * Packet splitter.\n *\n * The servers have a limit max_allowed_packet which limits the size of the data sent, to avoid saturating the server in memory.\n *\n * The following implementation has a workaround that will rewrite the command and separate the send according to this value.\n * This implies that this command can send multiple commands, with some tricks for sequencing packets.\n *\n */\n\nvar BulkPacket =\n/*#__PURE__*/\nfunction () {\n  function BulkPacket(opts, out, row) {\n    _classCallCheck(this, BulkPacket);\n\n    this.out = out;\n    this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n    this.pos = 4;\n    this.datatypes = [];\n    this.encoding = out.encoding;\n    this.waitingResponseNo = 1;\n    this.singleQuery = false;\n    this.haveErrorResponse = false;\n    this.writeBinaryDate = opts.tz ? this.writeBinaryTimezoneDate : this.writeBinaryLocalDate;\n\n    if (this.encoding === 'utf8') {\n      this.writeLengthEncodedString = this.writeDefaultLengthEncodedString;\n    } else if (Buffer.isEncoding(this.encoding)) {\n      this.writeLengthEncodedString = this.writeDefaultLengthEncodedString;\n    } else {\n      this.writeLengthEncodedString = this.writeIconvLengthEncodedString;\n    }\n\n    this.maxAllowedPacket = opts.maxAllowedPacket;\n    this.maxPacketSize = opts.maxAllowedPacket ? Math.min(MAX_BUFFER_SIZE, opts.maxAllowedPacket) : 4194304;\n    this.writeHeader(row);\n  }\n\n  _createClass(BulkPacket, [{\n    key: \"datatypeChanged\",\n    value: function datatypeChanged(row) {\n      if (this.datatypes.length !== row.length) return true;\n\n      for (var r = 0; r < row.length; r++) {\n        if (row[r] !== null) {\n          switch (typeof row[r]) {\n            case 'boolean':\n              if (this.datatypes[r] !== 0x01) return true;\n              break;\n\n            case 'number':\n              if (this.datatypes[r] !== 0x0f) return true;\n              break;\n\n            case 'object':\n              if (Object.prototype.toString.call(row[r]) === '[object Date]') {\n                if (this.datatypes[r] !== 0x0c) return true;\n              } else if (Buffer.isBuffer(row[r])) {\n                if (this.datatypes[r] !== 0xfb) return true;\n              } else if (row[r].type != null && ['Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon', 'GeometryCollection'].includes(row[r].type)) {\n                if (this.datatypes[r] !== 0xfb) return true;\n              } else {\n                if (this.datatypes[r] !== 0x0f) return true;\n              }\n\n              break;\n\n            default:\n              if (this.datatypes[r] !== 0x0f) return true;\n          }\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"writeHeader\",\n    value: function writeHeader(row) {\n      this.buf[this.pos++] = 0xfa; //use last prepare command\n\n      this.buf[this.pos++] = 0xff;\n      this.buf[this.pos++] = 0xff;\n      this.buf[this.pos++] = 0xff;\n      this.buf[this.pos++] = 0xff; //set bulk flags to Send types to server\n\n      this.buf[this.pos++] = 0x80;\n      this.buf[this.pos++] = 0x00; //send data type (strings)\n\n      this.datatypes = [];\n\n      if (row) {\n        for (var r = 0; r < row.length; r++) {\n          if (row[r] === null) {\n            this.buf[this.pos++] = 0x0f;\n          } else {\n            switch (typeof row[r]) {\n              case 'boolean':\n                this.buf[this.pos++] = 0x01;\n                break;\n\n              case 'number':\n                this.buf[this.pos++] = 0x0f;\n                break;\n\n              case 'object':\n                if (Object.prototype.toString.call(row[r]) === '[object Date]') {\n                  this.buf[this.pos++] = 0x0c;\n                } else if (Buffer.isBuffer(row[r])) {\n                  this.buf[this.pos++] = 0xfb;\n                } else if (row[r].type != null && ['Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon', 'GeometryCollection'].includes(row[r].type)) {\n                  this.buf[this.pos++] = 0xfb;\n                } else {\n                  this.buf[this.pos++] = 0x0f;\n                }\n\n                break;\n\n              default:\n                this.buf[this.pos++] = 0x0f;\n            }\n          }\n\n          this.datatypes[r] = this.buf[this.pos - 1];\n          this.buf[this.pos++] = 0x00;\n        }\n      }\n    }\n  }, {\n    key: \"growBuffer\",\n    value: function growBuffer(len) {\n      var newCapacity;\n\n      if (len + this.pos < MEDIUM_BUFFER_SIZE) {\n        newCapacity = MEDIUM_BUFFER_SIZE;\n      } else if (len + this.pos < LARGE_BUFFER_SIZE) {\n        newCapacity = LARGE_BUFFER_SIZE;\n      } else if (len + this.pos < BIG_BUFFER_SIZE) {\n        newCapacity = BIG_BUFFER_SIZE;\n      } else newCapacity = MAX_BUFFER_SIZE;\n\n      if (newCapacity > this.maxPacketSize && this.markPos) {\n        this.flush(false, len);\n        return true;\n      } else {\n        var newBuf = Buffer.allocUnsafe(Math.min(newCapacity));\n        this.buf.copy(newBuf, 0, 0, this.pos);\n        this.buf = newBuf;\n        return false;\n      }\n    }\n  }, {\n    key: \"writeLengthStringAscii\",\n    value: function writeLengthStringAscii(val) {\n      var len = val.length; //not enough space remaining\n\n      if (len >= this.buf.length - this.pos) {\n        var strBuf = Buffer.from(val, 'ascii');\n        return this.writeLengthEncodedBuffer(strBuf);\n      }\n\n      this.writeLength(len);\n\n      for (var off = 0; off < len;) {\n        this.buf[this.pos++] = val.charCodeAt(off++);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"writeLength\",\n    value: function writeLength(len) {\n      if (len < 0xfb) {\n        return this.writeInt8(len);\n      } else if (len < 65536) {\n        var flushed = this.writeInt8(0xfc);\n        return this.writeInt16(len) || flushed;\n      } else if (len < 16777216) {\n        var _flushed = this.writeInt8(0xfd);\n\n        return this.writeInt24(len) || _flushed;\n      } else {\n        //4 last bytes are filled with 0, packet limitation size is 32 bit integer\n        if (this.pos + 9 >= this.buf.length) {\n          var tmpBuf = Buffer.allocUnsafe(9);\n          tmpBuf[0] = 0xfe;\n          tmpBuf[1] = len;\n          tmpBuf[2] = len >>> 8;\n          tmpBuf[3] = len >>> 16;\n          tmpBuf[4] = len >>> 24;\n          tmpBuf[5] = 0;\n          tmpBuf[6] = 0;\n          tmpBuf[7] = 0;\n          tmpBuf[8] = 0;\n          return this.writeBuffer(tmpBuf);\n        }\n\n        this.buf[this.pos++] = 0xfe;\n        this.buf[this.pos++] = len;\n        this.buf[this.pos++] = len >>> 8;\n        this.buf[this.pos++] = len >>> 16;\n        this.buf[this.pos++] = len >>> 24;\n        this.buf[this.pos++] = 0;\n        this.buf[this.pos++] = 0;\n        this.buf[this.pos++] = 0;\n        this.buf[this.pos++] = 0;\n        return false;\n      }\n    }\n  }, {\n    key: \"writeLengthEncodedBuffer\",\n    value: function writeLengthEncodedBuffer(val) {\n      var valLen = val.length;\n      var flushed = this.writeLength(valLen);\n      return this.writeBuffer(val) || flushed;\n    }\n  }, {\n    key: \"writeBuffer\",\n    value: function writeBuffer(val) {\n      var flushed = false;\n      var valLen = val.length;\n\n      if (valLen > this.buf.length - this.pos) {\n        //makes buffer bigger (up to 16M)\n        if (this.buf.length < MAX_BUFFER_SIZE) flushed = this.growBuffer(valLen * 2); //data may still be bigger than buffer.\n        //must flush buffer when full (and reset position to 4)\n\n        if (valLen > this.buf.length - this.pos) {\n          var tmpPos = this.buf.length - this.pos;\n          val.copy(this.buf, this.pos, 0, tmpPos);\n          this.pos += tmpPos;\n          this.flush(false, valLen - tmpPos);\n\n          while (tmpPos < valLen) {\n            if (this.buf.length - this.pos < valLen - tmpPos) this.growBuffer(valLen - tmpPos);\n            var toWrite = Math.min(valLen - tmpPos, this.buf.length - this.pos);\n            val.copy(this.buf, this.pos, tmpPos, tmpPos + toWrite);\n            tmpPos += toWrite;\n            this.pos += toWrite;\n            if (valLen - tmpPos > 0) this.flush(false, valLen - tmpPos);\n          }\n\n          return true;\n        }\n      } //sure to have enough place to use buffer directly\n\n\n      val.copy(this.buf, this.pos, 0, valLen);\n      this.pos += valLen;\n      return flushed;\n    }\n  }, {\n    key: \"writeInt8\",\n    value: function writeInt8(value) {\n      var flushed = false;\n\n      if (this.pos + 1 > this.buf.length) {\n        if (this.buf.length < MAX_BUFFER_SIZE) {\n          flushed = this.growBuffer(1);\n        } else {\n          this.flush(false, 1);\n          this.buf[this.pos++] = value;\n          return true;\n        }\n      }\n\n      this.buf[this.pos++] = value;\n      return flushed;\n    }\n  }, {\n    key: \"writeInt16\",\n    value: function writeInt16(value) {\n      var flushed = false;\n\n      if (this.pos + 2 > this.buf.length) {\n        if (this.buf.length < this.maxPacketSize) flushed = this.growBuffer(2);\n\n        if (this.pos + 2 > this.buf.length) {\n          var tmpBuf = Buffer.allocUnsafe(2);\n          tmpBuf[0] = value;\n          tmpBuf[1] = value >>> 8;\n          this.writeBuffer(tmpBuf);\n          return true;\n        }\n      }\n\n      this.buf[this.pos++] = value;\n      this.buf[this.pos++] = value >>> 8;\n      return flushed;\n    }\n  }, {\n    key: \"writeInt24\",\n    value: function writeInt24(value) {\n      var flushed = false;\n\n      if (this.pos + 3 > this.buf.length) {\n        if (this.buf.length < this.maxPacketSize) flushed = this.growBuffer(3);\n\n        if (this.pos + 3 > this.buf.length) {\n          var tmpBuf = Buffer.allocUnsafe(3);\n          tmpBuf[0] = value;\n          tmpBuf[1] = value >>> 8;\n          tmpBuf[2] = value >>> 16;\n          this.writeBuffer(tmpBuf);\n          return true;\n        }\n      }\n\n      this.buf[this.pos++] = value;\n      this.buf[this.pos++] = value >>> 8;\n      this.buf[this.pos++] = value >>> 16;\n      return flushed;\n    }\n  }, {\n    key: \"writeIconvLengthEncodedString\",\n    value: function writeIconvLengthEncodedString(str) {\n      var buf = Iconv.encode(str, this.encoding);\n      return this.writeLengthEncodedBuffer(buf, 0, buf.length);\n    }\n  }, {\n    key: \"writeDefaultLengthEncodedString\",\n    value: function writeDefaultLengthEncodedString(str) {\n      //javascript use UCS-2 or UTF-16 string internal representation\n      //that means that string to byte will be a maximum of * 3\n      // (4 bytes utf-8 are represented on 2 UTF-16 characters)\n      if (str.length * 3 + 10 < this.buf.length - this.pos) {\n        //reserve position for length indicator\n        var maxLen = str.length * 3;\n        var lengthPos;\n\n        if (maxLen < 0xfb) {\n          lengthPos = this.pos;\n          this.pos++;\n        } else if (maxLen < 65536) {\n          this.buf[this.pos++] = 0xfc;\n          lengthPos = this.pos;\n          this.pos += 2;\n        } else {\n          //if len was > 16M, would have been > to buffer length\n          this.buf[this.pos++] = 0xfd;\n          lengthPos = this.pos;\n          this.pos += 3;\n        }\n\n        var prevPos = this.pos;\n        this.pos += this.buf.write(str, this.pos, this.encoding); //write real data length\n\n        var realLen = this.pos - prevPos;\n\n        if (maxLen < 0xfb) {\n          this.buf[lengthPos] = realLen;\n        } else if (maxLen < 65536) {\n          this.buf[lengthPos] = realLen;\n          this.buf[lengthPos + 1] = realLen >>> 8;\n        } else {\n          this.buf[lengthPos] = realLen;\n          this.buf[lengthPos + 1] = realLen >>> 8;\n          this.buf[lengthPos + 2] = realLen >>> 16;\n        }\n\n        return false;\n      } //checking real length\n\n\n      var flushed = false;\n      var byteLength = Buffer.byteLength(str, this.encoding);\n\n      if (byteLength + 9 > this.buf.length - this.pos) {\n        if (this.buf.length < MAX_BUFFER_SIZE) flushed = this.growBuffer(byteLength);\n\n        if (byteLength > this.buf.length - this.pos) {\n          //not enough space in buffer, will stream :\n          var strBuf = Buffer.from(str, this.encoding);\n          return this.writeLengthEncodedBuffer(strBuf) || flushed;\n        }\n      }\n\n      this.writeLength(byteLength);\n      this.pos += this.buf.write(str, this.pos, this.encoding);\n      return flushed;\n    }\n  }, {\n    key: \"writeBinaryLocalDate\",\n    value: function writeBinaryLocalDate(date, opts) {\n      var year = date.getFullYear();\n      var mon = date.getMonth() + 1;\n      var day = date.getDate();\n      var hour = date.getHours();\n      var min = date.getMinutes();\n      var sec = date.getSeconds();\n      var ms = date.getMilliseconds();\n      return this._writeBinaryDate(year, mon, day, hour, min, sec, ms);\n    }\n  }, {\n    key: \"_writeBinaryDate\",\n    value: function _writeBinaryDate(year, mon, day, hour, min, sec, ms) {\n      var len = ms === 0 ? 7 : 11; //not enough space remaining\n\n      if (len + 1 > this.buf.length - this.pos) {\n        var tmpBuf = Buffer.allocUnsafe(len + 1);\n        tmpBuf[0] = len;\n        tmpBuf[1] = year;\n        tmpBuf[2] = year >>> 8;\n        tmpBuf[3] = mon;\n        tmpBuf[4] = day;\n        tmpBuf[5] = hour;\n        tmpBuf[6] = min;\n        tmpBuf[7] = sec;\n\n        if (ms !== 0) {\n          var micro = ms * 1000;\n          tmpBuf[8] = micro;\n          tmpBuf[9] = micro >>> 8;\n          tmpBuf[10] = micro >>> 16;\n          tmpBuf[11] = micro >>> 24;\n        }\n\n        return this.writeBuffer(tmpBuf);\n      }\n\n      this.buf[this.pos] = len;\n      this.buf[this.pos + 1] = year;\n      this.buf[this.pos + 2] = year >>> 8;\n      this.buf[this.pos + 3] = mon;\n      this.buf[this.pos + 4] = day;\n      this.buf[this.pos + 5] = hour;\n      this.buf[this.pos + 6] = min;\n      this.buf[this.pos + 7] = sec;\n\n      if (ms !== 0) {\n        var _micro = ms * 1000;\n\n        this.buf[this.pos + 8] = _micro;\n        this.buf[this.pos + 9] = _micro >>> 8;\n        this.buf[this.pos + 10] = _micro >>> 16;\n        this.buf[this.pos + 11] = _micro >>> 24;\n      }\n\n      this.pos += len + 1;\n      return false;\n    }\n  }, {\n    key: \"writeBinaryTimezoneDate\",\n    value: function writeBinaryTimezoneDate(date, opts) {\n      var formated = opts.tz(date).format('YYYY-MM-DD HH:mm:ss.SSSSSS');\n      var dateZoned = new Date(formated + 'Z');\n      var year = dateZoned.getUTCFullYear();\n      var mon = dateZoned.getUTCMonth() + 1;\n      var day = dateZoned.getUTCDate();\n      var hour = dateZoned.getUTCHours();\n      var min = dateZoned.getUTCMinutes();\n      var sec = dateZoned.getUTCSeconds();\n      var ms = dateZoned.getUTCMilliseconds();\n      return this._writeBinaryDate(year, mon, day, hour, min, sec, ms);\n    }\n  }, {\n    key: \"mark\",\n    value: function mark(isLast, nextRow) {\n      var flushed = false;\n      this.nextRow = nextRow;\n\n      if (this.singleQuery) {\n        //end of big query that is more than 16M\n        //write single one\n        if (!this.haveErrorResponse) {\n          var packetSendSize = this.pos + (this.singleQuerySequenceNo !== undefined ? (this.singleQuerySequenceNo + 1) * MAX_BUFFER_SIZE : 0);\n\n          if (this.maxAllowedPacket && packetSendSize > this.maxAllowedPacket) {\n            console.log(\"will send a packet to db server with size > connection option 'maxAllowedPacket' (size send is \" + packetSendSize + ') connection might be reset by server');\n          }\n\n          this.copyAndFlush(true);\n          flushed = true;\n          this.markPos = undefined;\n        }\n\n        this.singleQuerySequenceNo = undefined;\n        this.singleQueryCompressSequenceNo = undefined;\n        this.singleQuery = false;\n        this.writeHeader(nextRow);\n        this.markPos = undefined;\n      } else {\n        if (!isLast && this.datatypeChanged(nextRow)) {\n          this.markPos = this.pos;\n          this.flushMark();\n          flushed = true;\n        } else if (this.markPos && this.pos > this.maxPacketSize) {\n          //not enough room for current query , flush mark.\n          this.flushMark();\n          flushed = true;\n        } else {\n          //just mark ending query\n          this.markPos = this.pos;\n\n          if (isLast) {\n            this.flushMark();\n            flushed = true;\n          }\n        }\n      }\n\n      return flushed;\n    }\n  }, {\n    key: \"flush\",\n    value: function flush(end, remainingLen) {\n      if (this.markPos && !this.singleQuery) {\n        this.flushMark();\n      } else {\n        //one insert is more than 16M, will continue to mono insert, hoping\n        //that max_allowed_packet is sized accordingly to query.\n        if (this.buf.length < MAX_BUFFER_SIZE) {\n          //in this case, connector has default to 4M packet, and a single query size\n          //is > to 4mb. growing buffer to 16M\n          var newBuf = Buffer.allocUnsafe(MAX_BUFFER_SIZE);\n          this.buf.copy(newBuf, 0, 0, this.pos);\n          this.buf = newBuf;\n        } else {\n          if (!this.haveErrorResponse) {\n            if (this.maxAllowedPacket && this.buf.length > this.maxAllowedPacket) {\n              console.log(\"will send a packet to server with size > connection option 'maxAllowedPacket' (size send is \" + this.pos + ') connection might be reset by server');\n            }\n\n            this.copyAndFlush(false);\n            this.markPos = undefined;\n            if (!this.singleQuery) this.waitingResponseNo++;\n            this.singleQuery = true;\n            this.singleQuerySequenceNo = this.out.cmd.sequenceNo;\n            this.singleQueryCompressSequenceNo = this.out.cmd.compressSequenceNo;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"flushMark\",\n    value: function flushMark() {\n      var afterMark;\n\n      if (this.pos !== this.markPos) {\n        afterMark = Buffer.allocUnsafe(this.pos - this.markPos);\n        this.buf.copy(afterMark, 0, this.markPos, this.pos);\n      }\n\n      this.pos = this.markPos;\n\n      if (!this.haveErrorResponse) {\n        this.copyAndFlush(true);\n        this.waitingResponseNo++;\n      }\n\n      this.pos = 4;\n      if (this.nextRow) this.writeHeader(this.nextRow);\n\n      if (afterMark) {\n        if (this.buf.length - this.pos < afterMark.length) this.growBuffer(afterMark.length - (this.buf.length - this.pos));\n        afterMark.copy(this.buf, this.pos, 0, afterMark.length);\n        this.pos += afterMark.length;\n      }\n\n      this.markPos = undefined;\n      this.singleQuery = false;\n      this.singleQuerySequenceNo = undefined;\n      this.singleQueryCompressSequenceNo = undefined;\n    }\n  }, {\n    key: \"copyAndFlush\",\n    value: function copyAndFlush(ended) {\n      this.out.buf = this.buf;\n      this.out.pos = this.pos;\n\n      if (this.singleQuerySequenceNo !== undefined) {\n        this.out.cmd.sequenceNo = this.singleQuerySequenceNo;\n        this.out.cmd.compressSequenceNo = this.singleQueryCompressSequenceNo;\n      } else {\n        this.out.cmd.sequenceNo = -1;\n        this.out.cmd.compressSequenceNo = -1;\n      }\n\n      this.out.flushBuffer(ended);\n\n      if (this.singleQuerySequenceNo !== undefined) {\n        this.singleQuerySequenceNo = this.out.cmd.sequenceNo;\n        this.singleQueryCompressSequenceNo = this.out.cmd.compressSequenceNo;\n      }\n\n      this.pos = 4;\n      this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n    }\n  }, {\n    key: \"endedWithError\",\n    value: function endedWithError() {\n      this.haveErrorResponse = true;\n    }\n  }]);\n\n  return BulkPacket;\n}();\n\nmodule.exports = BulkPacket;","map":{"version":3,"sources":["C:/Users/dembr/Documents/GitHub/react_projects/react-urol-database/node_modules/mariadb/lib/io/bulk-packet.js"],"names":["Iconv","require","SMALL_BUFFER_SIZE","MEDIUM_BUFFER_SIZE","LARGE_BUFFER_SIZE","BIG_BUFFER_SIZE","MAX_BUFFER_SIZE","BulkPacket","opts","out","row","buf","Buffer","allocUnsafe","pos","datatypes","encoding","waitingResponseNo","singleQuery","haveErrorResponse","writeBinaryDate","tz","writeBinaryTimezoneDate","writeBinaryLocalDate","writeLengthEncodedString","writeDefaultLengthEncodedString","isEncoding","writeIconvLengthEncodedString","maxAllowedPacket","maxPacketSize","Math","min","writeHeader","length","r","Object","prototype","toString","call","isBuffer","type","includes","len","newCapacity","markPos","flush","newBuf","copy","val","strBuf","from","writeLengthEncodedBuffer","writeLength","off","charCodeAt","writeInt8","flushed","writeInt16","writeInt24","tmpBuf","writeBuffer","valLen","growBuffer","tmpPos","toWrite","value","str","encode","maxLen","lengthPos","prevPos","write","realLen","byteLength","date","year","getFullYear","mon","getMonth","day","getDate","hour","getHours","getMinutes","sec","getSeconds","ms","getMilliseconds","_writeBinaryDate","micro","formated","format","dateZoned","Date","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","isLast","nextRow","packetSendSize","singleQuerySequenceNo","undefined","console","log","copyAndFlush","singleQueryCompressSequenceNo","datatypeChanged","flushMark","end","remainingLen","cmd","sequenceNo","compressSequenceNo","afterMark","ended","flushBuffer","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Iconv = require('iconv-lite');\nconst SMALL_BUFFER_SIZE = 1024;\nconst MEDIUM_BUFFER_SIZE = 16384; //16k\nconst LARGE_BUFFER_SIZE = 131072; //128k\nconst BIG_BUFFER_SIZE = 1048576; //1M\nconst MAX_BUFFER_SIZE = 16777219; //16M + 4\n\n/**\n * Packet splitter.\n *\n * The servers have a limit max_allowed_packet which limits the size of the data sent, to avoid saturating the server in memory.\n *\n * The following implementation has a workaround that will rewrite the command and separate the send according to this value.\n * This implies that this command can send multiple commands, with some tricks for sequencing packets.\n *\n */\nclass BulkPacket {\n  constructor(opts, out, row) {\n    this.out = out;\n    this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n    this.pos = 4;\n    this.datatypes = [];\n    this.encoding = out.encoding;\n    this.waitingResponseNo = 1;\n    this.singleQuery = false;\n    this.haveErrorResponse = false;\n    this.writeBinaryDate = opts.tz ? this.writeBinaryTimezoneDate : this.writeBinaryLocalDate;\n    if (this.encoding === 'utf8') {\n      this.writeLengthEncodedString = this.writeDefaultLengthEncodedString;\n    } else if (Buffer.isEncoding(this.encoding)) {\n      this.writeLengthEncodedString = this.writeDefaultLengthEncodedString;\n    } else {\n      this.writeLengthEncodedString = this.writeIconvLengthEncodedString;\n    }\n    this.maxAllowedPacket = opts.maxAllowedPacket;\n    this.maxPacketSize = opts.maxAllowedPacket\n      ? Math.min(MAX_BUFFER_SIZE, opts.maxAllowedPacket)\n      : 4194304;\n    this.writeHeader(row);\n  }\n\n  datatypeChanged(row) {\n    if (this.datatypes.length !== row.length) return true;\n    for (let r = 0; r < row.length; r++) {\n      if (row[r] !== null) {\n        switch (typeof row[r]) {\n          case 'boolean':\n            if (this.datatypes[r] !== 0x01) return true;\n            break;\n          case 'number':\n            if (this.datatypes[r] !== 0x0f) return true;\n            break;\n          case 'object':\n            if (Object.prototype.toString.call(row[r]) === '[object Date]') {\n              if (this.datatypes[r] !== 0x0c) return true;\n            } else if (Buffer.isBuffer(row[r])) {\n              if (this.datatypes[r] !== 0xfb) return true;\n            } else if (\n              row[r].type != null &&\n              [\n                'Point',\n                'LineString',\n                'Polygon',\n                'MultiPoint',\n                'MultiLineString',\n                'MultiPolygon',\n                'GeometryCollection'\n              ].includes(row[r].type)\n            ) {\n              if (this.datatypes[r] !== 0xfb) return true;\n            } else {\n              if (this.datatypes[r] !== 0x0f) return true;\n            }\n            break;\n          default:\n            if (this.datatypes[r] !== 0x0f) return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  writeHeader(row) {\n    this.buf[this.pos++] = 0xfa;\n\n    //use last prepare command\n    this.buf[this.pos++] = 0xff;\n    this.buf[this.pos++] = 0xff;\n    this.buf[this.pos++] = 0xff;\n    this.buf[this.pos++] = 0xff;\n\n    //set bulk flags to Send types to server\n    this.buf[this.pos++] = 0x80;\n    this.buf[this.pos++] = 0x00;\n\n    //send data type (strings)\n    this.datatypes = [];\n    if (row) {\n      for (let r = 0; r < row.length; r++) {\n        if (row[r] === null) {\n          this.buf[this.pos++] = 0x0f;\n        } else {\n          switch (typeof row[r]) {\n            case 'boolean':\n              this.buf[this.pos++] = 0x01;\n              break;\n            case 'number':\n              this.buf[this.pos++] = 0x0f;\n              break;\n            case 'object':\n              if (Object.prototype.toString.call(row[r]) === '[object Date]') {\n                this.buf[this.pos++] = 0x0c;\n              } else if (Buffer.isBuffer(row[r])) {\n                this.buf[this.pos++] = 0xfb;\n              } else if (\n                row[r].type != null &&\n                [\n                  'Point',\n                  'LineString',\n                  'Polygon',\n                  'MultiPoint',\n                  'MultiLineString',\n                  'MultiPolygon',\n                  'GeometryCollection'\n                ].includes(row[r].type)\n              ) {\n                this.buf[this.pos++] = 0xfb;\n              } else {\n                this.buf[this.pos++] = 0x0f;\n              }\n              break;\n            default:\n              this.buf[this.pos++] = 0x0f;\n          }\n        }\n        this.datatypes[r] = this.buf[this.pos - 1];\n        this.buf[this.pos++] = 0x00;\n      }\n    }\n  }\n\n  growBuffer(len) {\n    let newCapacity;\n    if (len + this.pos < MEDIUM_BUFFER_SIZE) {\n      newCapacity = MEDIUM_BUFFER_SIZE;\n    } else if (len + this.pos < LARGE_BUFFER_SIZE) {\n      newCapacity = LARGE_BUFFER_SIZE;\n    } else if (len + this.pos < BIG_BUFFER_SIZE) {\n      newCapacity = BIG_BUFFER_SIZE;\n    } else newCapacity = MAX_BUFFER_SIZE;\n\n    if (newCapacity > this.maxPacketSize && this.markPos) {\n      this.flush(false, len);\n      return true;\n    } else {\n      let newBuf = Buffer.allocUnsafe(Math.min(newCapacity));\n      this.buf.copy(newBuf, 0, 0, this.pos);\n      this.buf = newBuf;\n      return false;\n    }\n  }\n\n  writeLengthStringAscii(val) {\n    let len = val.length;\n    //not enough space remaining\n    if (len >= this.buf.length - this.pos) {\n      let strBuf = Buffer.from(val, 'ascii');\n      return this.writeLengthEncodedBuffer(strBuf);\n    }\n\n    this.writeLength(len);\n    for (let off = 0; off < len; ) {\n      this.buf[this.pos++] = val.charCodeAt(off++);\n    }\n    return false;\n  }\n\n  writeLength(len) {\n    if (len < 0xfb) {\n      return this.writeInt8(len);\n    } else if (len < 65536) {\n      let flushed = this.writeInt8(0xfc);\n      return this.writeInt16(len) || flushed;\n    } else if (len < 16777216) {\n      let flushed = this.writeInt8(0xfd);\n      return this.writeInt24(len) || flushed;\n    } else {\n      //4 last bytes are filled with 0, packet limitation size is 32 bit integer\n      if (this.pos + 9 >= this.buf.length) {\n        const tmpBuf = Buffer.allocUnsafe(9);\n        tmpBuf[0] = 0xfe;\n        tmpBuf[1] = len;\n        tmpBuf[2] = len >>> 8;\n        tmpBuf[3] = len >>> 16;\n        tmpBuf[4] = len >>> 24;\n        tmpBuf[5] = 0;\n        tmpBuf[6] = 0;\n        tmpBuf[7] = 0;\n        tmpBuf[8] = 0;\n        return this.writeBuffer(tmpBuf);\n      }\n      this.buf[this.pos++] = 0xfe;\n      this.buf[this.pos++] = len;\n      this.buf[this.pos++] = len >>> 8;\n      this.buf[this.pos++] = len >>> 16;\n      this.buf[this.pos++] = len >>> 24;\n      this.buf[this.pos++] = 0;\n      this.buf[this.pos++] = 0;\n      this.buf[this.pos++] = 0;\n      this.buf[this.pos++] = 0;\n      return false;\n    }\n  }\n\n  writeLengthEncodedBuffer(val) {\n    let valLen = val.length;\n    let flushed = this.writeLength(valLen);\n    return this.writeBuffer(val) || flushed;\n  }\n\n  writeBuffer(val) {\n    let flushed = false;\n    let valLen = val.length;\n    if (valLen > this.buf.length - this.pos) {\n      //makes buffer bigger (up to 16M)\n      if (this.buf.length < MAX_BUFFER_SIZE) flushed = this.growBuffer(valLen * 2);\n\n      //data may still be bigger than buffer.\n      //must flush buffer when full (and reset position to 4)\n      if (valLen > this.buf.length - this.pos) {\n        let tmpPos = this.buf.length - this.pos;\n        val.copy(this.buf, this.pos, 0, tmpPos);\n        this.pos += tmpPos;\n        this.flush(false, valLen - tmpPos);\n\n        while (tmpPos < valLen) {\n          if (this.buf.length - this.pos < valLen - tmpPos) this.growBuffer(valLen - tmpPos);\n          const toWrite = Math.min(valLen - tmpPos, this.buf.length - this.pos);\n          val.copy(this.buf, this.pos, tmpPos, tmpPos + toWrite);\n          tmpPos += toWrite;\n          this.pos += toWrite;\n          if (valLen - tmpPos > 0) this.flush(false, valLen - tmpPos);\n        }\n        return true;\n      }\n    }\n\n    //sure to have enough place to use buffer directly\n    val.copy(this.buf, this.pos, 0, valLen);\n    this.pos += valLen;\n    return flushed;\n  }\n\n  writeInt8(value) {\n    let flushed = false;\n    if (this.pos + 1 > this.buf.length) {\n      if (this.buf.length < MAX_BUFFER_SIZE) {\n        flushed = this.growBuffer(1);\n      } else {\n        this.flush(false, 1);\n        this.buf[this.pos++] = value;\n        return true;\n      }\n    }\n    this.buf[this.pos++] = value;\n    return flushed;\n  }\n\n  writeInt16(value) {\n    let flushed = false;\n    if (this.pos + 2 > this.buf.length) {\n      if (this.buf.length < this.maxPacketSize) flushed = this.growBuffer(2);\n      if (this.pos + 2 > this.buf.length) {\n        const tmpBuf = Buffer.allocUnsafe(2);\n        tmpBuf[0] = value;\n        tmpBuf[1] = value >>> 8;\n        this.writeBuffer(tmpBuf);\n        return true;\n      }\n    }\n    this.buf[this.pos++] = value;\n    this.buf[this.pos++] = value >>> 8;\n    return flushed;\n  }\n\n  writeInt24(value) {\n    let flushed = false;\n    if (this.pos + 3 > this.buf.length) {\n      if (this.buf.length < this.maxPacketSize) flushed = this.growBuffer(3);\n      if (this.pos + 3 > this.buf.length) {\n        const tmpBuf = Buffer.allocUnsafe(3);\n        tmpBuf[0] = value;\n        tmpBuf[1] = value >>> 8;\n        tmpBuf[2] = value >>> 16;\n        this.writeBuffer(tmpBuf);\n        return true;\n      }\n    }\n    this.buf[this.pos++] = value;\n    this.buf[this.pos++] = value >>> 8;\n    this.buf[this.pos++] = value >>> 16;\n    return flushed;\n  }\n\n  writeIconvLengthEncodedString(str) {\n    let buf = Iconv.encode(str, this.encoding);\n    return this.writeLengthEncodedBuffer(buf, 0, buf.length);\n  }\n\n  writeDefaultLengthEncodedString(str) {\n    //javascript use UCS-2 or UTF-16 string internal representation\n    //that means that string to byte will be a maximum of * 3\n    // (4 bytes utf-8 are represented on 2 UTF-16 characters)\n    if (str.length * 3 + 10 < this.buf.length - this.pos) {\n      //reserve position for length indicator\n      const maxLen = str.length * 3;\n      let lengthPos;\n      if (maxLen < 0xfb) {\n        lengthPos = this.pos;\n        this.pos++;\n      } else if (maxLen < 65536) {\n        this.buf[this.pos++] = 0xfc;\n        lengthPos = this.pos;\n        this.pos += 2;\n      } else {\n        //if len was > 16M, would have been > to buffer length\n        this.buf[this.pos++] = 0xfd;\n        lengthPos = this.pos;\n        this.pos += 3;\n      }\n      const prevPos = this.pos;\n      this.pos += this.buf.write(str, this.pos, this.encoding);\n      //write real data length\n      const realLen = this.pos - prevPos;\n      if (maxLen < 0xfb) {\n        this.buf[lengthPos] = realLen;\n      } else if (maxLen < 65536) {\n        this.buf[lengthPos] = realLen;\n        this.buf[lengthPos + 1] = realLen >>> 8;\n      } else {\n        this.buf[lengthPos] = realLen;\n        this.buf[lengthPos + 1] = realLen >>> 8;\n        this.buf[lengthPos + 2] = realLen >>> 16;\n      }\n      return false;\n    }\n\n    //checking real length\n    let flushed = false;\n    let byteLength = Buffer.byteLength(str, this.encoding);\n    if (byteLength + 9 > this.buf.length - this.pos) {\n      if (this.buf.length < MAX_BUFFER_SIZE) flushed = this.growBuffer(byteLength);\n\n      if (byteLength > this.buf.length - this.pos) {\n        //not enough space in buffer, will stream :\n        let strBuf = Buffer.from(str, this.encoding);\n        return this.writeLengthEncodedBuffer(strBuf) || flushed;\n      }\n    }\n    this.writeLength(byteLength);\n    this.pos += this.buf.write(str, this.pos, this.encoding);\n    return flushed;\n  }\n\n  writeBinaryLocalDate(date, opts) {\n    const year = date.getFullYear();\n    const mon = date.getMonth() + 1;\n    const day = date.getDate();\n    const hour = date.getHours();\n    const min = date.getMinutes();\n    const sec = date.getSeconds();\n    const ms = date.getMilliseconds();\n    return this._writeBinaryDate(year, mon, day, hour, min, sec, ms);\n  }\n\n  _writeBinaryDate(year, mon, day, hour, min, sec, ms) {\n    let len = ms === 0 ? 7 : 11;\n    //not enough space remaining\n    if (len + 1 > this.buf.length - this.pos) {\n      let tmpBuf = Buffer.allocUnsafe(len + 1);\n\n      tmpBuf[0] = len;\n      tmpBuf[1] = year;\n      tmpBuf[2] = year >>> 8;\n      tmpBuf[3] = mon;\n      tmpBuf[4] = day;\n      tmpBuf[5] = hour;\n      tmpBuf[6] = min;\n      tmpBuf[7] = sec;\n      if (ms !== 0) {\n        const micro = ms * 1000;\n        tmpBuf[8] = micro;\n        tmpBuf[9] = micro >>> 8;\n        tmpBuf[10] = micro >>> 16;\n        tmpBuf[11] = micro >>> 24;\n      }\n\n      return this.writeBuffer(tmpBuf);\n    }\n\n    this.buf[this.pos] = len;\n    this.buf[this.pos + 1] = year;\n    this.buf[this.pos + 2] = year >>> 8;\n    this.buf[this.pos + 3] = mon;\n    this.buf[this.pos + 4] = day;\n    this.buf[this.pos + 5] = hour;\n    this.buf[this.pos + 6] = min;\n    this.buf[this.pos + 7] = sec;\n\n    if (ms !== 0) {\n      const micro = ms * 1000;\n      this.buf[this.pos + 8] = micro;\n      this.buf[this.pos + 9] = micro >>> 8;\n      this.buf[this.pos + 10] = micro >>> 16;\n      this.buf[this.pos + 11] = micro >>> 24;\n    }\n    this.pos += len + 1;\n    return false;\n  }\n\n  writeBinaryTimezoneDate(date, opts) {\n    const formated = opts.tz(date).format('YYYY-MM-DD HH:mm:ss.SSSSSS');\n    const dateZoned = new Date(formated + 'Z');\n\n    const year = dateZoned.getUTCFullYear();\n    const mon = dateZoned.getUTCMonth() + 1;\n    const day = dateZoned.getUTCDate();\n    const hour = dateZoned.getUTCHours();\n    const min = dateZoned.getUTCMinutes();\n    const sec = dateZoned.getUTCSeconds();\n    const ms = dateZoned.getUTCMilliseconds();\n    return this._writeBinaryDate(year, mon, day, hour, min, sec, ms);\n  }\n\n  mark(isLast, nextRow) {\n    let flushed = false;\n    this.nextRow = nextRow;\n    if (this.singleQuery) {\n      //end of big query that is more than 16M\n      //write single one\n      if (!this.haveErrorResponse) {\n        const packetSendSize =\n          this.pos +\n          (this.singleQuerySequenceNo !== undefined\n            ? (this.singleQuerySequenceNo + 1) * MAX_BUFFER_SIZE\n            : 0);\n        if (this.maxAllowedPacket && packetSendSize > this.maxAllowedPacket) {\n          console.log(\n            \"will send a packet to db server with size > connection option 'maxAllowedPacket' (size send is \" +\n              packetSendSize +\n              ') connection might be reset by server'\n          );\n        }\n        this.copyAndFlush(true);\n        flushed = true;\n        this.markPos = undefined;\n      }\n\n      this.singleQuerySequenceNo = undefined;\n      this.singleQueryCompressSequenceNo = undefined;\n      this.singleQuery = false;\n      this.writeHeader(nextRow);\n      this.markPos = undefined;\n    } else {\n      if (!isLast && this.datatypeChanged(nextRow)) {\n        this.markPos = this.pos;\n        this.flushMark();\n        flushed = true;\n      } else if (this.markPos && this.pos > this.maxPacketSize) {\n        //not enough room for current query , flush mark.\n        this.flushMark();\n        flushed = true;\n      } else {\n        //just mark ending query\n        this.markPos = this.pos;\n        if (isLast) {\n          this.flushMark();\n          flushed = true;\n        }\n      }\n    }\n    return flushed;\n  }\n\n  flush(end, remainingLen) {\n    if (this.markPos && !this.singleQuery) {\n      this.flushMark();\n    } else {\n      //one insert is more than 16M, will continue to mono insert, hoping\n      //that max_allowed_packet is sized accordingly to query.\n      if (this.buf.length < MAX_BUFFER_SIZE) {\n        //in this case, connector has default to 4M packet, and a single query size\n        //is > to 4mb. growing buffer to 16M\n        let newBuf = Buffer.allocUnsafe(MAX_BUFFER_SIZE);\n        this.buf.copy(newBuf, 0, 0, this.pos);\n        this.buf = newBuf;\n      } else {\n        if (!this.haveErrorResponse) {\n          if (this.maxAllowedPacket && this.buf.length > this.maxAllowedPacket) {\n            console.log(\n              \"will send a packet to server with size > connection option 'maxAllowedPacket' (size send is \" +\n                this.pos +\n                ') connection might be reset by server'\n            );\n          }\n          this.copyAndFlush(false);\n\n          this.markPos = undefined;\n          if (!this.singleQuery) this.waitingResponseNo++;\n          this.singleQuery = true;\n          this.singleQuerySequenceNo = this.out.cmd.sequenceNo;\n          this.singleQueryCompressSequenceNo = this.out.cmd.compressSequenceNo;\n        }\n      }\n    }\n  }\n\n  flushMark() {\n    let afterMark;\n    if (this.pos !== this.markPos) {\n      afterMark = Buffer.allocUnsafe(this.pos - this.markPos);\n      this.buf.copy(afterMark, 0, this.markPos, this.pos);\n    }\n\n    this.pos = this.markPos;\n\n    if (!this.haveErrorResponse) {\n      this.copyAndFlush(true);\n      this.waitingResponseNo++;\n    }\n\n    this.pos = 4;\n    if (this.nextRow) this.writeHeader(this.nextRow);\n    if (afterMark) {\n      if (this.buf.length - this.pos < afterMark.length)\n        this.growBuffer(afterMark.length - (this.buf.length - this.pos));\n      afterMark.copy(this.buf, this.pos, 0, afterMark.length);\n      this.pos += afterMark.length;\n    }\n    this.markPos = undefined;\n    this.singleQuery = false;\n    this.singleQuerySequenceNo = undefined;\n    this.singleQueryCompressSequenceNo = undefined;\n  }\n\n  copyAndFlush(ended) {\n    this.out.buf = this.buf;\n    this.out.pos = this.pos;\n    if (this.singleQuerySequenceNo !== undefined) {\n      this.out.cmd.sequenceNo = this.singleQuerySequenceNo;\n      this.out.cmd.compressSequenceNo = this.singleQueryCompressSequenceNo;\n    } else {\n      this.out.cmd.sequenceNo = -1;\n      this.out.cmd.compressSequenceNo = -1;\n    }\n    this.out.flushBuffer(ended);\n    if (this.singleQuerySequenceNo !== undefined) {\n      this.singleQuerySequenceNo = this.out.cmd.sequenceNo;\n      this.singleQueryCompressSequenceNo = this.out.cmd.compressSequenceNo;\n    }\n    this.pos = 4;\n    this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n  }\n\n  endedWithError() {\n    this.haveErrorResponse = true;\n  }\n}\n\nmodule.exports = BulkPacket;\n"]},"metadata":{},"sourceType":"script"}