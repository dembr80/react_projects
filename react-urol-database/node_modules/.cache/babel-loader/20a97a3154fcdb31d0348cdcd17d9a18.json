{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\dembr\\\\Documents\\\\GitHub\\\\react_projects\\\\react-urol-database\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\dembr\\\\Documents\\\\GitHub\\\\react_projects\\\\react-urol-database\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar Iconv = require('iconv-lite');\n\nvar QUOTE = 0x27;\nvar DBL_QUOTE = 0x22;\nvar ZERO_BYTE = 0x00;\nvar SLASH = 0x5c;\nvar SMALL_BUFFER_SIZE = 1024;\nvar MEDIUM_BUFFER_SIZE = 16384; //16k\n\nvar LARGE_BUFFER_SIZE = 131072; //128k\n\nvar BIG_BUFFER_SIZE = 1048576; //1M\n\nvar MAX_BUFFER_SIZE = 16777219; //16M + 4\n\nvar CHARS_GLOBAL_REGEXP = /[\\0\\\"\\'\\\\]/g; // eslint-disable-line no-control-regex\n\n/**\n * Packet splitter.\n *\n * The servers have a limit max_allowed_packet which limits the size of the data sent, to avoid saturating the server in memory.\n *\n * The following implementation has a workaround that will rewrite the command and separate the send according to this value.\n * This implies that this command can send multiple commands, with some tricks for sequencing packets.\n *\n */\n\nvar ReWritePacket =\n/*#__PURE__*/\nfunction () {\n  function ReWritePacket(maxAllowedPacket, out, initString, endString) {\n    _classCallCheck(this, ReWritePacket);\n\n    this.out = out;\n    this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n    this.pos = 4;\n    this.initStr = initString;\n    this.endStr = endString;\n    this.encoding = out.encoding;\n    this.endStrLength = Buffer.byteLength(this.endStr, this.encoding);\n    this.waitingResponseNo = 0;\n    this.singleQuery = false;\n    this.haveErrorResponse = false;\n\n    if (this.encoding === 'utf8') {\n      this.writeString = this.writeDefaultBufferString;\n      this.writeStringEscapeQuote = this.writeUtf8StringEscapeQuote;\n    } else if (Buffer.isEncoding(this.encoding)) {\n      this.writeString = this.writeDefaultBufferString;\n      this.writeStringEscapeQuote = this.writeDefaultStringEscapeQuote;\n    } else {\n      this.writeString = this.writeDefaultIconvString;\n      this.writeStringEscapeQuote = this.writeDefaultStringEscapeQuote;\n    }\n\n    this.maxAllowedPacket = maxAllowedPacket;\n\n    if (maxAllowedPacket) {\n      this.maxPacketSize = Math.min(MAX_BUFFER_SIZE, maxAllowedPacket) - this.endStrLength;\n    } else this.maxPacketSize = 4194304 - this.endStrLength;\n\n    this.buf[this.pos++] = 0x03;\n    this.writeString(this.initStr);\n  }\n\n  _createClass(ReWritePacket, [{\n    key: \"growBuffer\",\n    value: function growBuffer(len) {\n      var newCapacity;\n\n      if (len + this.pos < MEDIUM_BUFFER_SIZE) {\n        newCapacity = MEDIUM_BUFFER_SIZE;\n      } else if (len + this.pos < LARGE_BUFFER_SIZE) {\n        newCapacity = LARGE_BUFFER_SIZE;\n      } else if (len + this.pos < BIG_BUFFER_SIZE) {\n        newCapacity = BIG_BUFFER_SIZE;\n      } else newCapacity = MAX_BUFFER_SIZE;\n\n      if (newCapacity > this.maxPacketSize && this.markPos) {\n        this.flush(false, len);\n        return true;\n      }\n\n      var newBuf = Buffer.allocUnsafe(Math.min(newCapacity));\n      this.buf.copy(newBuf, 0, 0, this.pos);\n      this.buf = newBuf;\n      return false;\n    }\n  }, {\n    key: \"writeInt8\",\n    value: function writeInt8(value) {\n      var flushed = false;\n\n      if (this.pos + 1 + this.endStrLength >= this.buf.length) {\n        if (this.buf.length < MAX_BUFFER_SIZE) {\n          flushed = this.growBuffer(1);\n        } else {\n          this.flush(false, 1);\n          this.buf[this.pos++] = value;\n          return true;\n        }\n      }\n\n      this.buf[this.pos++] = value;\n      return flushed;\n    }\n    /**\n     * Write ascii string to socket (no escaping)\n     *\n     * @param str                string\n     */\n\n  }, {\n    key: \"writeStringAscii\",\n    value: function writeStringAscii(str) {\n      var len = str.length; //not enough space remaining\n\n      if (len >= this.buf.length - (this.pos + this.endStrLength)) {\n        var strBuf = Buffer.from(str, 'ascii');\n        return this.writeBuffer(strBuf, 0, strBuf.length);\n      }\n\n      for (var off = 0; off < len;) {\n        this.buf[this.pos++] = str.charCodeAt(off++);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"writeUtf8StringEscapeQuote\",\n    value: function writeUtf8StringEscapeQuote(str) {\n      var charsLength = str.length; //not enough space remaining\n\n      if (charsLength * 3 + 2 >= this.buf.length - (this.pos + this.endStrLength)) {\n        var flushed;\n        var arr = Buffer.from(str, 'utf8');\n        flushed = this.writeInt8(QUOTE);\n        flushed = this.writeBufferEscape(arr) || flushed;\n        flushed = this.writeInt8(QUOTE) || flushed;\n        return flushed;\n      } //create UTF-8 byte array\n      //since javascript char are internally using UTF-16 using surrogate's pattern, 4 bytes unicode characters will\n      //represent 2 characters : example \"\\uD83C\\uDFA4\" = ðŸŽ¤ unicode 8 \"no microphones\"\n      //so max size is 3 * charLength\n      //(escape characters are 1 byte encoded, so length might only be 2 when escaped)\n      // + 2 for the quotes for text protocol\n\n\n      var charsOffset = 0;\n      var currChar;\n      this.buf[this.pos++] = QUOTE; //quick loop if only ASCII chars for faster escape\n\n      for (; charsOffset < charsLength && (currChar = str.charCodeAt(charsOffset)) < 0x80; charsOffset++) {\n        if (currChar === SLASH || currChar === QUOTE || currChar === ZERO_BYTE || currChar === DBL_QUOTE) {\n          this.buf[this.pos++] = SLASH;\n        }\n\n        this.buf[this.pos++] = currChar;\n      } //if quick loop not finished\n\n\n      while (charsOffset < charsLength) {\n        currChar = str.charCodeAt(charsOffset++);\n\n        if (currChar < 0x80) {\n          if (currChar === SLASH || currChar === QUOTE || currChar === ZERO_BYTE || currChar === DBL_QUOTE) {\n            this.buf[this.pos++] = SLASH;\n          }\n\n          this.buf[this.pos++] = currChar;\n        } else if (currChar < 0x800) {\n          this.buf[this.pos++] = 0xc0 | currChar >> 6;\n          this.buf[this.pos++] = 0x80 | currChar & 0x3f;\n        } else if (currChar >= 0xd800 && currChar < 0xe000) {\n          //reserved for surrogate - see https://en.wikipedia.org/wiki/UTF-16\n          if (currChar < 0xdc00) {\n            //is high surrogate\n            if (charsOffset + 1 > charsLength) {\n              this.buf[this.pos++] = 0x3f;\n            } else {\n              var nextChar = str.charCodeAt(charsOffset);\n\n              if (nextChar >= 0xdc00 && nextChar < 0xe000) {\n                //is low surrogate\n                var surrogatePairs = (currChar << 10) + nextChar + (0x010000 - (0xd800 << 10) - 0xdc00);\n                this.buf[this.pos++] = 0xf0 | surrogatePairs >> 18;\n                this.buf[this.pos++] = 0x80 | surrogatePairs >> 12 & 0x3f;\n                this.buf[this.pos++] = 0x80 | surrogatePairs >> 6 & 0x3f;\n                this.buf[this.pos++] = 0x80 | surrogatePairs & 0x3f;\n                charsOffset++;\n              } else {\n                //must have low surrogate\n                this.buf[this.pos++] = 0x3f;\n              }\n            }\n          } else {\n            //low surrogate without high surrogate before\n            this.buf[this.pos++] = 0x3f;\n          }\n        } else {\n          this.buf[this.pos++] = 0xe0 | currChar >> 12;\n          this.buf[this.pos++] = 0x80 | currChar >> 6 & 0x3f;\n          this.buf[this.pos++] = 0x80 | currChar & 0x3f;\n        }\n      }\n\n      this.buf[this.pos++] = QUOTE;\n      return false;\n    }\n  }, {\n    key: \"writeDefaultIconvString\",\n    value: function writeDefaultIconvString(str) {\n      var buf = Iconv.encode(str, this.encoding);\n      return this.writeBuffer(buf, 0, buf.length);\n    }\n  }, {\n    key: \"writeDefaultBufferString\",\n    value: function writeDefaultBufferString(str) {\n      //javascript use UCS-2 or UTF-16 string internal representation\n      //that means that string to byte will be a maximum of * 3\n      // (4 bytes utf-8 are represented on 2 UTF-16 characters)\n      if (str.length * 3 < this.buf.length - (this.pos + this.endStrLength)) {\n        this.pos += this.buf.write(str, this.pos, this.encoding);\n        return false;\n      } //checking real length\n\n\n      var flushed = false;\n      var byteLength = Buffer.byteLength(str, this.encoding);\n\n      if (byteLength > this.buf.length - (this.pos + this.endStrLength)) {\n        if (this.buf.length < MAX_BUFFER_SIZE) {\n          flushed = this.growBuffer(byteLength);\n        }\n\n        if (byteLength > this.buf.length - (this.pos + this.endStrLength)) {\n          //not enough space in buffer, will stream :\n          var strBuf = Buffer.from(str, this.encoding);\n          flushed = this.writeBuffer(strBuf, 0, strBuf.length) || flushed;\n          return flushed;\n        }\n      }\n\n      this.pos += this.buf.write(str, this.pos, this.encoding);\n      return flushed;\n    }\n    /**\n     * Parameters need to be properly escaped :\n     * following characters are to be escaped by \"\\\" :\n     * - \\0\n     * - \\\\\n     * - \\'\n     * - \\\"\n     * regex split part of string writing part, and escaping special char.\n     * Those chars are <= 7f meaning that this will work even with multi-byte encoding\n     *\n     * @param str string to escape.\n     */\n\n  }, {\n    key: \"writeDefaultStringEscapeQuote\",\n    value: function writeDefaultStringEscapeQuote(str) {\n      var flushed = this.writeInt8(QUOTE);\n      var match;\n      var lastIndex = 0;\n\n      while ((match = CHARS_GLOBAL_REGEXP.exec(str)) !== null) {\n        flushed = this.writeString(str.slice(lastIndex, match.index)) || flushed;\n        flushed = this.writeInt8(SLASH) || flushed;\n        flushed = this.writeInt8(match[0].charCodeAt(0)) || flushed;\n        lastIndex = CHARS_GLOBAL_REGEXP.lastIndex;\n      }\n\n      if (lastIndex === 0) {\n        // Nothing was escaped\n        flushed = this.writeString(str) || flushed;\n        flushed = this.writeInt8(QUOTE) || flushed;\n        return flushed;\n      }\n\n      if (lastIndex < str.length) {\n        flushed = this.writeString(str.slice(lastIndex)) || flushed;\n      }\n\n      flushed = this.writeInt8(QUOTE) || flushed;\n      return flushed;\n    }\n  }, {\n    key: \"writeBufferEscape\",\n    value: function writeBufferEscape(val) {\n      var flushed = false;\n      var valLen = val.length;\n\n      if (valLen * 2 > this.buf.length - (this.pos + this.endStrLength)) {\n        //makes buffer bigger (up to 16M)\n        if (this.buf.length < MAX_BUFFER_SIZE) flushed = this.growBuffer(valLen * 2); //data may still be bigger than buffer.\n        //must flush buffer when full (and reset position to 4)\n\n        if (valLen * 2 > this.buf.length - (this.pos + this.endStrLength)) {\n          //not enough space in buffer, will fill buffer\n          for (var i = 0; i < valLen; i++) {\n            switch (val[i]) {\n              case QUOTE:\n              case SLASH:\n              case DBL_QUOTE:\n              case ZERO_BYTE:\n                if (this.pos >= this.buf.length) this.flush(false, (valLen - i) * 2);\n                this.buf[this.pos++] = SLASH;\n              //add escape slash\n            }\n\n            if (this.pos >= this.buf.length) this.flush(false, (valLen - i) * 2);\n            this.buf[this.pos++] = val[i];\n          }\n\n          return true;\n        }\n      } //sure to have enough place to use buffer directly\n\n\n      for (var _i = 0; _i < valLen; _i++) {\n        switch (val[_i]) {\n          case QUOTE:\n          case SLASH:\n          case DBL_QUOTE:\n          case ZERO_BYTE:\n            this.buf[this.pos++] = SLASH;\n          //add escape slash\n        }\n\n        this.buf[this.pos++] = val[_i];\n      }\n\n      return flushed;\n    }\n  }, {\n    key: \"writeBuffer\",\n    value: function writeBuffer(arr, off, len) {\n      var flushed = false;\n\n      if (len > this.buf.length - (this.pos + this.endStrLength)) {\n        if (this.buf.length < MAX_BUFFER_SIZE) flushed = this.growBuffer(len); //max buffer size\n\n        if (len > this.buf.length - (this.pos + this.endStrLength)) {\n          //not enough space in buffer, will stream :\n          // fill buffer and flush until all data are snd\n          var remainingLen = len;\n\n          while (true) {\n            //filling buffer\n            var lenToFillBuffer = Math.min(MAX_BUFFER_SIZE - this.pos, remainingLen);\n            arr.copy(this.buf, this.pos, off, off + lenToFillBuffer);\n            remainingLen -= lenToFillBuffer;\n            off += lenToFillBuffer;\n            this.pos += lenToFillBuffer;\n            if (remainingLen === 0) return flushed;\n            this.flush(false, remainingLen);\n            flushed = true;\n          }\n        }\n      }\n\n      arr.copy(this.buf, this.pos, off, off + len);\n      this.pos += len;\n      return flushed;\n    }\n  }, {\n    key: \"mark\",\n    value: function mark(isLast) {\n      var flushed = false;\n\n      if (this.singleQuery) {\n        //end of big query that is more than 16M\n        //write single one\n        flushed = this.writeString(this.endStr);\n\n        if (!this.haveErrorResponse) {\n          var packetSendSize = this.pos + (this.singleQuerySequenceNo != undefined ? (this.singleQuerySequenceNo + 1) * MAX_BUFFER_SIZE : 0);\n\n          if (this.maxAllowedPacket && packetSendSize > this.maxAllowedPacket) {\n            console.log(\"will send a packet to db server with size > connection option 'maxAllowedPacket' (size send is \" + packetSendSize + ') connection might be reset by server');\n          }\n\n          this.copyAndFlush(true);\n          flushed = true;\n          this.markPos = undefined;\n        }\n\n        this.singleQuerySequenceNo = undefined;\n        this.singleQueryCompressSequenceNo = undefined;\n        this.singleQuery = false;\n        this.buf[this.pos++] = 0x03;\n        this.writeString(this.initStr);\n        this.markPos = undefined;\n      } else {\n        if (this.markPos && this.pos + this.endStrLength > this.maxPacketSize) {\n          //not enough room for current query, flush mark.\n          this.flushMark();\n          flushed = true;\n        } else {\n          //just mark ending query\n          this.markPos = this.pos;\n\n          if (isLast) {\n            this.flushMark();\n            flushed = true;\n          }\n        }\n\n        if (!isLast) flushed = this.writeStringAscii(',') || flushed;\n      }\n\n      return flushed;\n    }\n  }, {\n    key: \"flush\",\n    value: function flush(end, remainingLen) {\n      if (this.markPos && !this.singleQuery) {\n        this.flushMark();\n      } else {\n        //one insert is more than 16M, will continue to mono insert, hoping\n        //that max_allowed_packet is sized accordingly to query.\n        if (this.buf.length < MAX_BUFFER_SIZE) {\n          //in this case, connector has default to 4M packet, and a single query size\n          //is > to 4mb. growing buffer to 16M\n          var newBuf = Buffer.allocUnsafe(MAX_BUFFER_SIZE);\n          this.buf.copy(newBuf, 0, 0, this.pos);\n          this.buf = newBuf;\n        } else {\n          if (!this.haveErrorResponse) {\n            if (this.maxAllowedPacket && this.buf.length > this.maxAllowedPacket) {\n              console.log(\"will send a packet to server with size > connection option 'maxAllowedPacket' (size send is \" + this.pos + ') connection might be reset by server');\n            }\n\n            this.copyAndFlush(false);\n            this.markPos = undefined;\n            if (!this.singleQuery) this.waitingResponseNo++;\n            this.singleQuery = true;\n            this.singleQuerySequenceNo = this.out.cmd.sequenceNo;\n            this.singleQueryCompressSequenceNo = this.out.cmd.compressSequenceNo;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"flushMark\",\n    value: function flushMark() {\n      var afterMark;\n\n      if (this.pos !== this.markPos) {\n        //remove \",\" character\n        afterMark = Buffer.allocUnsafe(this.pos - this.markPos - 1);\n        this.buf.copy(afterMark, 0, this.markPos + 1, this.pos);\n      }\n\n      this.pos = this.markPos;\n      this.writeString(this.endStr);\n\n      if (!this.haveErrorResponse) {\n        this.copyAndFlush(true);\n        this.waitingResponseNo++;\n      }\n\n      this.pos = 4;\n      this.buf[this.pos++] = 0x03;\n      this.writeString(this.initStr);\n\n      if (afterMark) {\n        if (this.buf.length - this.pos < afterMark.length) this.growBuffer(afterMark.length - (this.buf.length - this.pos));\n        afterMark.copy(this.buf, this.pos, 0, afterMark.length);\n        this.pos += afterMark.length;\n      }\n\n      this.markPos = undefined;\n      this.singleQuery = false;\n      this.singleQuerySequenceNo = undefined;\n      this.singleQueryCompressSequenceNo = undefined;\n    }\n  }, {\n    key: \"copyAndFlush\",\n    value: function copyAndFlush(ended) {\n      this.out.buf = this.buf;\n      this.out.pos = this.pos;\n\n      if (this.singleQuerySequenceNo != undefined) {\n        this.out.cmd.sequenceNo = this.singleQuerySequenceNo;\n        this.out.cmd.compressSequenceNo = this.singleQueryCompressSequenceNo;\n      } else {\n        this.out.cmd.sequenceNo = -1;\n        this.out.cmd.compressSequenceNo = -1;\n      }\n\n      this.out.flushBuffer(ended);\n\n      if (this.singleQuerySequenceNo != undefined) {\n        this.singleQuerySequenceNo = this.out.cmd.sequenceNo;\n        this.singleQueryCompressSequenceNo = this.out.cmd.compressSequenceNo;\n      }\n\n      this.pos = 4;\n      this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n    }\n  }, {\n    key: \"endedWithError\",\n    value: function endedWithError() {\n      this.haveErrorResponse = true;\n    }\n  }]);\n\n  return ReWritePacket;\n}();\n\nmodule.exports = ReWritePacket;","map":{"version":3,"sources":["C:/Users/dembr/Documents/GitHub/react_projects/react-urol-database/node_modules/mariadb/lib/io/rewrite-packet.js"],"names":["Iconv","require","QUOTE","DBL_QUOTE","ZERO_BYTE","SLASH","SMALL_BUFFER_SIZE","MEDIUM_BUFFER_SIZE","LARGE_BUFFER_SIZE","BIG_BUFFER_SIZE","MAX_BUFFER_SIZE","CHARS_GLOBAL_REGEXP","ReWritePacket","maxAllowedPacket","out","initString","endString","buf","Buffer","allocUnsafe","pos","initStr","endStr","encoding","endStrLength","byteLength","waitingResponseNo","singleQuery","haveErrorResponse","writeString","writeDefaultBufferString","writeStringEscapeQuote","writeUtf8StringEscapeQuote","isEncoding","writeDefaultStringEscapeQuote","writeDefaultIconvString","maxPacketSize","Math","min","len","newCapacity","markPos","flush","newBuf","copy","value","flushed","length","growBuffer","str","strBuf","from","writeBuffer","off","charCodeAt","charsLength","arr","writeInt8","writeBufferEscape","charsOffset","currChar","nextChar","surrogatePairs","encode","write","match","lastIndex","exec","slice","index","val","valLen","i","remainingLen","lenToFillBuffer","isLast","packetSendSize","singleQuerySequenceNo","undefined","console","log","copyAndFlush","singleQueryCompressSequenceNo","flushMark","writeStringAscii","end","cmd","sequenceNo","compressSequenceNo","afterMark","ended","flushBuffer","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Iconv = require('iconv-lite');\n\nconst QUOTE = 0x27;\nconst DBL_QUOTE = 0x22;\nconst ZERO_BYTE = 0x00;\nconst SLASH = 0x5c;\n\nconst SMALL_BUFFER_SIZE = 1024;\nconst MEDIUM_BUFFER_SIZE = 16384; //16k\nconst LARGE_BUFFER_SIZE = 131072; //128k\nconst BIG_BUFFER_SIZE = 1048576; //1M\nconst MAX_BUFFER_SIZE = 16777219; //16M + 4\n\nconst CHARS_GLOBAL_REGEXP = /[\\0\\\"\\'\\\\]/g; // eslint-disable-line no-control-regex\n\n/**\n * Packet splitter.\n *\n * The servers have a limit max_allowed_packet which limits the size of the data sent, to avoid saturating the server in memory.\n *\n * The following implementation has a workaround that will rewrite the command and separate the send according to this value.\n * This implies that this command can send multiple commands, with some tricks for sequencing packets.\n *\n */\nclass ReWritePacket {\n  constructor(maxAllowedPacket, out, initString, endString) {\n    this.out = out;\n    this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n    this.pos = 4;\n    this.initStr = initString;\n    this.endStr = endString;\n    this.encoding = out.encoding;\n    this.endStrLength = Buffer.byteLength(this.endStr, this.encoding);\n    this.waitingResponseNo = 0;\n    this.singleQuery = false;\n    this.haveErrorResponse = false;\n\n    if (this.encoding === 'utf8') {\n      this.writeString = this.writeDefaultBufferString;\n      this.writeStringEscapeQuote = this.writeUtf8StringEscapeQuote;\n    } else if (Buffer.isEncoding(this.encoding)) {\n      this.writeString = this.writeDefaultBufferString;\n      this.writeStringEscapeQuote = this.writeDefaultStringEscapeQuote;\n    } else {\n      this.writeString = this.writeDefaultIconvString;\n      this.writeStringEscapeQuote = this.writeDefaultStringEscapeQuote;\n    }\n    this.maxAllowedPacket = maxAllowedPacket;\n    if (maxAllowedPacket) {\n      this.maxPacketSize = Math.min(MAX_BUFFER_SIZE, maxAllowedPacket) - this.endStrLength;\n    } else this.maxPacketSize = 4194304 - this.endStrLength;\n\n    this.buf[this.pos++] = 0x03;\n    this.writeString(this.initStr);\n  }\n\n  growBuffer(len) {\n    let newCapacity;\n    if (len + this.pos < MEDIUM_BUFFER_SIZE) {\n      newCapacity = MEDIUM_BUFFER_SIZE;\n    } else if (len + this.pos < LARGE_BUFFER_SIZE) {\n      newCapacity = LARGE_BUFFER_SIZE;\n    } else if (len + this.pos < BIG_BUFFER_SIZE) {\n      newCapacity = BIG_BUFFER_SIZE;\n    } else newCapacity = MAX_BUFFER_SIZE;\n\n    if (newCapacity > this.maxPacketSize && this.markPos) {\n      this.flush(false, len);\n      return true;\n    }\n    let newBuf = Buffer.allocUnsafe(Math.min(newCapacity));\n    this.buf.copy(newBuf, 0, 0, this.pos);\n    this.buf = newBuf;\n    return false;\n  }\n\n  writeInt8(value) {\n    let flushed = false;\n    if (this.pos + 1 + this.endStrLength >= this.buf.length) {\n      if (this.buf.length < MAX_BUFFER_SIZE) {\n        flushed = this.growBuffer(1);\n      } else {\n        this.flush(false, 1);\n        this.buf[this.pos++] = value;\n        return true;\n      }\n    }\n    this.buf[this.pos++] = value;\n    return flushed;\n  }\n\n  /**\n   * Write ascii string to socket (no escaping)\n   *\n   * @param str                string\n   */\n  writeStringAscii(str) {\n    let len = str.length;\n\n    //not enough space remaining\n    if (len >= this.buf.length - (this.pos + this.endStrLength)) {\n      let strBuf = Buffer.from(str, 'ascii');\n      return this.writeBuffer(strBuf, 0, strBuf.length);\n    }\n\n    for (let off = 0; off < len; ) {\n      this.buf[this.pos++] = str.charCodeAt(off++);\n    }\n    return false;\n  }\n\n  writeUtf8StringEscapeQuote(str) {\n    const charsLength = str.length;\n\n    //not enough space remaining\n    if (charsLength * 3 + 2 >= this.buf.length - (this.pos + this.endStrLength)) {\n      let flushed;\n      const arr = Buffer.from(str, 'utf8');\n      flushed = this.writeInt8(QUOTE);\n      flushed = this.writeBufferEscape(arr) || flushed;\n      flushed = this.writeInt8(QUOTE) || flushed;\n      return flushed;\n    }\n\n    //create UTF-8 byte array\n    //since javascript char are internally using UTF-16 using surrogate's pattern, 4 bytes unicode characters will\n    //represent 2 characters : example \"\\uD83C\\uDFA4\" = ðŸŽ¤ unicode 8 \"no microphones\"\n    //so max size is 3 * charLength\n    //(escape characters are 1 byte encoded, so length might only be 2 when escaped)\n    // + 2 for the quotes for text protocol\n    let charsOffset = 0;\n    let currChar;\n    this.buf[this.pos++] = QUOTE;\n    //quick loop if only ASCII chars for faster escape\n    for (\n      ;\n      charsOffset < charsLength && (currChar = str.charCodeAt(charsOffset)) < 0x80;\n      charsOffset++\n    ) {\n      if (\n        currChar === SLASH ||\n        currChar === QUOTE ||\n        currChar === ZERO_BYTE ||\n        currChar === DBL_QUOTE\n      ) {\n        this.buf[this.pos++] = SLASH;\n      }\n      this.buf[this.pos++] = currChar;\n    }\n\n    //if quick loop not finished\n    while (charsOffset < charsLength) {\n      currChar = str.charCodeAt(charsOffset++);\n      if (currChar < 0x80) {\n        if (\n          currChar === SLASH ||\n          currChar === QUOTE ||\n          currChar === ZERO_BYTE ||\n          currChar === DBL_QUOTE\n        ) {\n          this.buf[this.pos++] = SLASH;\n        }\n        this.buf[this.pos++] = currChar;\n      } else if (currChar < 0x800) {\n        this.buf[this.pos++] = 0xc0 | (currChar >> 6);\n        this.buf[this.pos++] = 0x80 | (currChar & 0x3f);\n      } else if (currChar >= 0xd800 && currChar < 0xe000) {\n        //reserved for surrogate - see https://en.wikipedia.org/wiki/UTF-16\n        if (currChar < 0xdc00) {\n          //is high surrogate\n          if (charsOffset + 1 > charsLength) {\n            this.buf[this.pos++] = 0x3f;\n          } else {\n            const nextChar = str.charCodeAt(charsOffset);\n            if (nextChar >= 0xdc00 && nextChar < 0xe000) {\n              //is low surrogate\n              const surrogatePairs =\n                (currChar << 10) + nextChar + (0x010000 - (0xd800 << 10) - 0xdc00);\n              this.buf[this.pos++] = 0xf0 | (surrogatePairs >> 18);\n              this.buf[this.pos++] = 0x80 | ((surrogatePairs >> 12) & 0x3f);\n              this.buf[this.pos++] = 0x80 | ((surrogatePairs >> 6) & 0x3f);\n              this.buf[this.pos++] = 0x80 | (surrogatePairs & 0x3f);\n              charsOffset++;\n            } else {\n              //must have low surrogate\n              this.buf[this.pos++] = 0x3f;\n            }\n          }\n        } else {\n          //low surrogate without high surrogate before\n          this.buf[this.pos++] = 0x3f;\n        }\n      } else {\n        this.buf[this.pos++] = 0xe0 | (currChar >> 12);\n        this.buf[this.pos++] = 0x80 | ((currChar >> 6) & 0x3f);\n        this.buf[this.pos++] = 0x80 | (currChar & 0x3f);\n      }\n    }\n    this.buf[this.pos++] = QUOTE;\n    return false;\n  }\n\n  writeDefaultIconvString(str) {\n    let buf = Iconv.encode(str, this.encoding);\n    return this.writeBuffer(buf, 0, buf.length);\n  }\n\n  writeDefaultBufferString(str) {\n    //javascript use UCS-2 or UTF-16 string internal representation\n    //that means that string to byte will be a maximum of * 3\n    // (4 bytes utf-8 are represented on 2 UTF-16 characters)\n    if (str.length * 3 < this.buf.length - (this.pos + this.endStrLength)) {\n      this.pos += this.buf.write(str, this.pos, this.encoding);\n      return false;\n    }\n\n    //checking real length\n    let flushed = false;\n    let byteLength = Buffer.byteLength(str, this.encoding);\n    if (byteLength > this.buf.length - (this.pos + this.endStrLength)) {\n      if (this.buf.length < MAX_BUFFER_SIZE) {\n        flushed = this.growBuffer(byteLength);\n      }\n      if (byteLength > this.buf.length - (this.pos + this.endStrLength)) {\n        //not enough space in buffer, will stream :\n        let strBuf = Buffer.from(str, this.encoding);\n        flushed = this.writeBuffer(strBuf, 0, strBuf.length) || flushed;\n        return flushed;\n      }\n    }\n    this.pos += this.buf.write(str, this.pos, this.encoding);\n    return flushed;\n  }\n\n  /**\n   * Parameters need to be properly escaped :\n   * following characters are to be escaped by \"\\\" :\n   * - \\0\n   * - \\\\\n   * - \\'\n   * - \\\"\n   * regex split part of string writing part, and escaping special char.\n   * Those chars are <= 7f meaning that this will work even with multi-byte encoding\n   *\n   * @param str string to escape.\n   */\n  writeDefaultStringEscapeQuote(str) {\n    let flushed = this.writeInt8(QUOTE);\n    let match;\n    let lastIndex = 0;\n    while ((match = CHARS_GLOBAL_REGEXP.exec(str)) !== null) {\n      flushed = this.writeString(str.slice(lastIndex, match.index)) || flushed;\n      flushed = this.writeInt8(SLASH) || flushed;\n      flushed = this.writeInt8(match[0].charCodeAt(0)) || flushed;\n      lastIndex = CHARS_GLOBAL_REGEXP.lastIndex;\n    }\n\n    if (lastIndex === 0) {\n      // Nothing was escaped\n      flushed = this.writeString(str) || flushed;\n      flushed = this.writeInt8(QUOTE) || flushed;\n      return flushed;\n    }\n\n    if (lastIndex < str.length) {\n      flushed = this.writeString(str.slice(lastIndex)) || flushed;\n    }\n    flushed = this.writeInt8(QUOTE) || flushed;\n    return flushed;\n  }\n\n  writeBufferEscape(val) {\n    let flushed = false;\n    let valLen = val.length;\n    if (valLen * 2 > this.buf.length - (this.pos + this.endStrLength)) {\n      //makes buffer bigger (up to 16M)\n      if (this.buf.length < MAX_BUFFER_SIZE) flushed = this.growBuffer(valLen * 2);\n\n      //data may still be bigger than buffer.\n      //must flush buffer when full (and reset position to 4)\n      if (valLen * 2 > this.buf.length - (this.pos + this.endStrLength)) {\n        //not enough space in buffer, will fill buffer\n        for (let i = 0; i < valLen; i++) {\n          switch (val[i]) {\n            case QUOTE:\n            case SLASH:\n            case DBL_QUOTE:\n            case ZERO_BYTE:\n              if (this.pos >= this.buf.length) this.flush(false, (valLen - i) * 2);\n              this.buf[this.pos++] = SLASH; //add escape slash\n          }\n          if (this.pos >= this.buf.length) this.flush(false, (valLen - i) * 2);\n          this.buf[this.pos++] = val[i];\n        }\n        return true;\n      }\n    }\n\n    //sure to have enough place to use buffer directly\n    for (let i = 0; i < valLen; i++) {\n      switch (val[i]) {\n        case QUOTE:\n        case SLASH:\n        case DBL_QUOTE:\n        case ZERO_BYTE:\n          this.buf[this.pos++] = SLASH; //add escape slash\n      }\n      this.buf[this.pos++] = val[i];\n    }\n    return flushed;\n  }\n\n  writeBuffer(arr, off, len) {\n    let flushed = false;\n    if (len > this.buf.length - (this.pos + this.endStrLength)) {\n      if (this.buf.length < MAX_BUFFER_SIZE) flushed = this.growBuffer(len);\n\n      //max buffer size\n      if (len > this.buf.length - (this.pos + this.endStrLength)) {\n        //not enough space in buffer, will stream :\n        // fill buffer and flush until all data are snd\n        let remainingLen = len;\n\n        while (true) {\n          //filling buffer\n          let lenToFillBuffer = Math.min(MAX_BUFFER_SIZE - this.pos, remainingLen);\n          arr.copy(this.buf, this.pos, off, off + lenToFillBuffer);\n          remainingLen -= lenToFillBuffer;\n          off += lenToFillBuffer;\n          this.pos += lenToFillBuffer;\n\n          if (remainingLen === 0) return flushed;\n          this.flush(false, remainingLen);\n          flushed = true;\n        }\n      }\n    }\n    arr.copy(this.buf, this.pos, off, off + len);\n    this.pos += len;\n    return flushed;\n  }\n\n  mark(isLast) {\n    let flushed = false;\n    if (this.singleQuery) {\n      //end of big query that is more than 16M\n      //write single one\n      flushed = this.writeString(this.endStr);\n\n      if (!this.haveErrorResponse) {\n        const packetSendSize =\n          this.pos +\n          (this.singleQuerySequenceNo != undefined\n            ? (this.singleQuerySequenceNo + 1) * MAX_BUFFER_SIZE\n            : 0);\n        if (this.maxAllowedPacket && packetSendSize > this.maxAllowedPacket) {\n          console.log(\n            \"will send a packet to db server with size > connection option 'maxAllowedPacket' (size send is \" +\n              packetSendSize +\n              ') connection might be reset by server'\n          );\n        }\n        this.copyAndFlush(true);\n        flushed = true;\n        this.markPos = undefined;\n      }\n\n      this.singleQuerySequenceNo = undefined;\n      this.singleQueryCompressSequenceNo = undefined;\n      this.singleQuery = false;\n      this.buf[this.pos++] = 0x03;\n      this.writeString(this.initStr);\n      this.markPos = undefined;\n    } else {\n      if (this.markPos && this.pos + this.endStrLength > this.maxPacketSize) {\n        //not enough room for current query, flush mark.\n        this.flushMark();\n        flushed = true;\n      } else {\n        //just mark ending query\n        this.markPos = this.pos;\n        if (isLast) {\n          this.flushMark();\n          flushed = true;\n        }\n      }\n      if (!isLast) flushed = this.writeStringAscii(',') || flushed;\n    }\n    return flushed;\n  }\n\n  flush(end, remainingLen) {\n    if (this.markPos && !this.singleQuery) {\n      this.flushMark();\n    } else {\n      //one insert is more than 16M, will continue to mono insert, hoping\n      //that max_allowed_packet is sized accordingly to query.\n      if (this.buf.length < MAX_BUFFER_SIZE) {\n        //in this case, connector has default to 4M packet, and a single query size\n        //is > to 4mb. growing buffer to 16M\n        let newBuf = Buffer.allocUnsafe(MAX_BUFFER_SIZE);\n        this.buf.copy(newBuf, 0, 0, this.pos);\n        this.buf = newBuf;\n      } else {\n        if (!this.haveErrorResponse) {\n          if (this.maxAllowedPacket && this.buf.length > this.maxAllowedPacket) {\n            console.log(\n              \"will send a packet to server with size > connection option 'maxAllowedPacket' (size send is \" +\n                this.pos +\n                ') connection might be reset by server'\n            );\n          }\n          this.copyAndFlush(false);\n\n          this.markPos = undefined;\n          if (!this.singleQuery) this.waitingResponseNo++;\n          this.singleQuery = true;\n          this.singleQuerySequenceNo = this.out.cmd.sequenceNo;\n          this.singleQueryCompressSequenceNo = this.out.cmd.compressSequenceNo;\n        }\n      }\n    }\n  }\n\n  flushMark() {\n    let afterMark;\n    if (this.pos !== this.markPos) {\n      //remove \",\" character\n      afterMark = Buffer.allocUnsafe(this.pos - this.markPos - 1);\n      this.buf.copy(afterMark, 0, this.markPos + 1, this.pos);\n    }\n\n    this.pos = this.markPos;\n    this.writeString(this.endStr);\n\n    if (!this.haveErrorResponse) {\n      this.copyAndFlush(true);\n      this.waitingResponseNo++;\n    }\n\n    this.pos = 4;\n    this.buf[this.pos++] = 0x03;\n    this.writeString(this.initStr);\n    if (afterMark) {\n      if (this.buf.length - this.pos < afterMark.length)\n        this.growBuffer(afterMark.length - (this.buf.length - this.pos));\n      afterMark.copy(this.buf, this.pos, 0, afterMark.length);\n      this.pos += afterMark.length;\n    }\n    this.markPos = undefined;\n    this.singleQuery = false;\n    this.singleQuerySequenceNo = undefined;\n    this.singleQueryCompressSequenceNo = undefined;\n  }\n\n  copyAndFlush(ended) {\n    this.out.buf = this.buf;\n    this.out.pos = this.pos;\n    if (this.singleQuerySequenceNo != undefined) {\n      this.out.cmd.sequenceNo = this.singleQuerySequenceNo;\n      this.out.cmd.compressSequenceNo = this.singleQueryCompressSequenceNo;\n    } else {\n      this.out.cmd.sequenceNo = -1;\n      this.out.cmd.compressSequenceNo = -1;\n    }\n    this.out.flushBuffer(ended);\n    if (this.singleQuerySequenceNo != undefined) {\n      this.singleQuerySequenceNo = this.out.cmd.sequenceNo;\n      this.singleQueryCompressSequenceNo = this.out.cmd.compressSequenceNo;\n    }\n    this.pos = 4;\n    this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n  }\n\n  endedWithError() {\n    this.haveErrorResponse = true;\n  }\n}\n\nmodule.exports = ReWritePacket;\n"]},"metadata":{},"sourceType":"script"}