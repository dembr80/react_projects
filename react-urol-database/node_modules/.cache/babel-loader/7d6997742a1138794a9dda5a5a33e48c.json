{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\dembr\\\\Documents\\\\GitHub\\\\react_projects\\\\react-urol-database\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\dembr\\\\Documents\\\\GitHub\\\\react_projects\\\\react-urol-database\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar ZLib = require('zlib');\n\nvar Utils = require('../misc/utils');\n/**\n * MySQL packet parser\n * see : https://mariadb.com/kb/en/library/0-packet/\n */\n\n\nvar CompressionInputStream =\n/*#__PURE__*/\nfunction () {\n  function CompressionInputStream(reader, receiveQueue, opts, info) {\n    _classCallCheck(this, CompressionInputStream);\n\n    this.reader = reader;\n    this.receiveQueue = receiveQueue;\n    this.info = info;\n    this.opts = opts;\n    this.header = Buffer.allocUnsafe(7);\n    this.headerLen = 0;\n    this.compressPacketLen = null;\n    this.packetLen = null;\n    this.remainingLen = null;\n    this.parts = null;\n    this.partsTotalLen = 0;\n  }\n\n  _createClass(CompressionInputStream, [{\n    key: \"receivePacket\",\n    value: function receivePacket(chunk) {\n      var cmd = this.currentCmd();\n\n      if (this.opts.debugCompress) {\n        console.log('<== conn:%d %s (compress)\\n%s', this.info.threadId ? this.info.threadId : -1, cmd ? cmd.onPacketReceive ? cmd.constructor.name + '.' + cmd.onPacketReceive.name : cmd.constructor.name : 'no command', Utils.log(this.opts, chunk, 0, chunk.length, this.header));\n      }\n\n      if (cmd) cmd.compressSequenceNo = this.header[3];\n      var unCompressLen = this.header[4] | this.header[5] << 8 | this.header[6] << 16;\n\n      if (unCompressLen === 0) {\n        this.reader.onData(chunk);\n      } else {\n        //use synchronous inflating, to ensure FIFO packet order\n        var unCompressChunk = ZLib.inflateSync(chunk);\n        this.reader.onData(unCompressChunk);\n      }\n    }\n  }, {\n    key: \"currentCmd\",\n    value: function currentCmd() {\n      var cmd;\n\n      while (cmd = this.receiveQueue.peek()) {\n        if (cmd.onPacketReceive) return cmd;\n        this.receiveQueue.shift();\n      }\n\n      return null;\n    }\n  }, {\n    key: \"resetHeader\",\n    value: function resetHeader() {\n      this.remainingLen = null;\n      this.headerLen = 0;\n    }\n  }, {\n    key: \"onData\",\n    value: function onData(chunk) {\n      var pos = 0;\n      var length;\n      var chunkLen = chunk.length;\n\n      do {\n        if (this.remainingLen) {\n          length = this.remainingLen;\n        } else {\n          length = null;\n\n          while (chunkLen - pos > 0) {\n            this.header[this.headerLen++] = chunk[pos++];\n\n            if (this.headerLen === 7) {\n              this.compressPacketLen = this.header[0] + (this.header[1] << 8) + (this.header[2] << 16);\n              this.packetLen = this.header[4] | this.header[5] << 8 | this.header[6] << 16;\n              if (this.packetLen === 0) this.packetLen = this.compressPacketLen;\n              length = this.compressPacketLen;\n              break;\n            }\n          }\n        }\n\n        if (length) {\n          if (chunkLen - pos >= length) {\n            var buf = chunk.slice(pos, pos + length);\n            pos += length;\n\n            if (this.parts) {\n              this.parts.push(buf);\n              this.partsTotalLen += length;\n\n              if (this.compressPacketLen < 0xffffff) {\n                var _buf = Buffer.concat(this.parts, this.partsTotalLen);\n\n                this.parts = null;\n                this.receivePacket(_buf);\n              }\n            } else {\n              if (this.compressPacketLen < 0xffffff) {\n                this.receivePacket(buf);\n              } else {\n                this.parts = [buf];\n                this.partsTotalLen = length;\n              }\n            }\n\n            this.resetHeader();\n          } else {\n            var _buf2 = chunk.slice(pos, chunkLen);\n\n            if (!this.parts) {\n              this.parts = [_buf2];\n              this.partsTotalLen = chunkLen - pos;\n            } else {\n              this.parts.push(_buf2);\n              this.partsTotalLen += chunkLen - pos;\n            }\n\n            this.remainingLen = length - (chunkLen - pos);\n            return;\n          }\n        }\n      } while (pos < chunkLen);\n    }\n  }]);\n\n  return CompressionInputStream;\n}();\n\nmodule.exports = CompressionInputStream;","map":{"version":3,"sources":["C:/Users/dembr/Documents/GitHub/react_projects/react-urol-database/node_modules/mariadb/lib/io/compression-input-stream.js"],"names":["ZLib","require","Utils","CompressionInputStream","reader","receiveQueue","opts","info","header","Buffer","allocUnsafe","headerLen","compressPacketLen","packetLen","remainingLen","parts","partsTotalLen","chunk","cmd","currentCmd","debugCompress","console","log","threadId","onPacketReceive","constructor","name","length","compressSequenceNo","unCompressLen","onData","unCompressChunk","inflateSync","peek","shift","pos","chunkLen","buf","slice","push","concat","receivePacket","resetHeader","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst ZLib = require('zlib');\nconst Utils = require('../misc/utils');\n\n/**\n * MySQL packet parser\n * see : https://mariadb.com/kb/en/library/0-packet/\n */\nclass CompressionInputStream {\n  constructor(reader, receiveQueue, opts, info) {\n    this.reader = reader;\n    this.receiveQueue = receiveQueue;\n    this.info = info;\n    this.opts = opts;\n    this.header = Buffer.allocUnsafe(7);\n    this.headerLen = 0;\n    this.compressPacketLen = null;\n    this.packetLen = null;\n    this.remainingLen = null;\n\n    this.parts = null;\n    this.partsTotalLen = 0;\n  }\n\n  receivePacket(chunk) {\n    let cmd = this.currentCmd();\n    if (this.opts.debugCompress) {\n      console.log(\n        '<== conn:%d %s (compress)\\n%s',\n        this.info.threadId ? this.info.threadId : -1,\n        cmd\n          ? cmd.onPacketReceive\n            ? cmd.constructor.name + '.' + cmd.onPacketReceive.name\n            : cmd.constructor.name\n          : 'no command',\n        Utils.log(this.opts, chunk, 0, chunk.length, this.header)\n      );\n    }\n    if (cmd) cmd.compressSequenceNo = this.header[3];\n    const unCompressLen = this.header[4] | (this.header[5] << 8) | (this.header[6] << 16);\n    if (unCompressLen === 0) {\n      this.reader.onData(chunk);\n    } else {\n      //use synchronous inflating, to ensure FIFO packet order\n      const unCompressChunk = ZLib.inflateSync(chunk);\n      this.reader.onData(unCompressChunk);\n    }\n  }\n\n  currentCmd() {\n    let cmd;\n    while ((cmd = this.receiveQueue.peek())) {\n      if (cmd.onPacketReceive) return cmd;\n      this.receiveQueue.shift();\n    }\n    return null;\n  }\n\n  resetHeader() {\n    this.remainingLen = null;\n    this.headerLen = 0;\n  }\n\n  onData(chunk) {\n    let pos = 0;\n    let length;\n    const chunkLen = chunk.length;\n\n    do {\n      if (this.remainingLen) {\n        length = this.remainingLen;\n      } else {\n        length = null;\n        while (chunkLen - pos > 0) {\n          this.header[this.headerLen++] = chunk[pos++];\n          if (this.headerLen === 7) {\n            this.compressPacketLen =\n              this.header[0] + (this.header[1] << 8) + (this.header[2] << 16);\n            this.packetLen = this.header[4] | (this.header[5] << 8) | (this.header[6] << 16);\n            if (this.packetLen === 0) this.packetLen = this.compressPacketLen;\n            length = this.compressPacketLen;\n            break;\n          }\n        }\n      }\n\n      if (length) {\n        if (chunkLen - pos >= length) {\n          const buf = chunk.slice(pos, pos + length);\n          pos += length;\n          if (this.parts) {\n            this.parts.push(buf);\n            this.partsTotalLen += length;\n\n            if (this.compressPacketLen < 0xffffff) {\n              let buf = Buffer.concat(this.parts, this.partsTotalLen);\n              this.parts = null;\n              this.receivePacket(buf);\n            }\n          } else {\n            if (this.compressPacketLen < 0xffffff) {\n              this.receivePacket(buf);\n            } else {\n              this.parts = [buf];\n              this.partsTotalLen = length;\n            }\n          }\n          this.resetHeader();\n        } else {\n          const buf = chunk.slice(pos, chunkLen);\n          if (!this.parts) {\n            this.parts = [buf];\n            this.partsTotalLen = chunkLen - pos;\n          } else {\n            this.parts.push(buf);\n            this.partsTotalLen += chunkLen - pos;\n          }\n          this.remainingLen = length - (chunkLen - pos);\n          return;\n        }\n      }\n    } while (pos < chunkLen);\n  }\n}\n\nmodule.exports = CompressionInputStream;\n"]},"metadata":{},"sourceType":"script"}