{"ast":null,"code":"'use strict';\n\nvar EventEmitter = require('events');\n\nvar util = require('util');\n\nvar Queue = require('denque');\n\nvar Errors = require('./misc/errors');\n\nvar Utils = require('./misc/utils');\n\nfunction PoolBase(options, processTask, createConnectionPool, pingPromise) {\n  var _this = this;\n\n  //*****************************************************************\n  // public methods\n  //*****************************************************************\n\n  /**\n   * Retrieve a connection from pool.\n   * Create a new one, if limit is not reached.\n   * wait until acquireTimeout.\n   *\n   * @return {Promise}\n   */\n  this.getConnection = function () {\n    return addRequest(this);\n  };\n  /**\n   * Execute a query on one connection from pool.\n   *\n   * @param sql   sql command\n   * @param value parameter value of sql command (not mandatory)\n   * @return {Promise}\n   */\n\n\n  this.query = function (sql, value) {\n    return addRequest(this, sql, value, false);\n  };\n  /**\n   * Execute a batch on one connection from pool.\n   *\n   * @param sql   sql command\n   * @param value parameter value of sql command (not mandatory)\n   * @return {Promise}\n   */\n\n\n  this.batch = function (sql, value) {\n    return addRequest(this, sql, value, true);\n  };\n  /**\n   * Close all connection in pool\n   *\n   * @return Promise\n   */\n\n\n  this.end = function () {\n    if (closed) {\n      return Promise.reject(Errors.createError('pool is already closed', false, null, 'HY000', Errors.ER_POOL_ALREADY_CLOSED, undefined, false));\n    }\n\n    closed = true;\n    clearInterval(idleMaintainingTask); //close unused connections\n\n    var idleConnectionsEndings = [];\n    var conn;\n\n    while (conn = idleConnections.shift()) {\n      idleConnectionsEndings.push(conn.forceEnd());\n    }\n\n    firstTaskTimeout = clearTimeout(firstTaskTimeout); //reject all waiting task\n\n    if (taskQueue.size() > 0) {\n      var task;\n      var err = Errors.createError('pool is ending, connection request aborted', false, null, 'HY000', Errors.ER_CLOSING_POOL, undefined, false);\n\n      while (task = taskQueue.shift()) {\n        process.nextTick(task.reject, err);\n      }\n    }\n\n    return Promise.all(idleConnectionsEndings);\n  };\n  /**\n   * Get current active connections.\n   * @return {number}\n   */\n\n\n  this.activeConnections = function () {\n    return Object.keys(activeConnections).length;\n  };\n  /**\n   * Get current total connection number.\n   * @return {number}\n   */\n\n\n  this.totalConnections = function () {\n    return this.activeConnections() + this.idleConnections();\n  };\n  /**\n   * Get current idle connection number.\n   * @return {number}\n   */\n\n\n  this.idleConnections = function () {\n    return idleConnections.size();\n  };\n  /**\n   * Get current stacked connection request.\n   * @return {number}\n   */\n\n\n  this.taskQueueSize = function () {\n    return taskQueue.size();\n  };\n  /**\n   * First connection creation.\n   * activation is slightly different than pooling grow : If connection fails, there is many retries for 30s\n   * (option initializationTimeout).\n   * If connection fails, error will be thrown to request / console if no request, to ensure that error is thrown.\n   */\n\n\n  this.initialize = function () {\n    connectionInCreation = true;\n    var self = this;\n    var timeoutEnd = Date.now() + opts.initializationTimeout;\n    connectionCreationLoop(self, 0, timeoutEnd).then(function (conn) {\n      //add to pool\n      if (closed) {\n        conn.forceEnd().catch(function (err) {});\n      } else {\n        addPoolConnection(self, conn);\n\n        if (opts.idleTimeout > 0) {\n          idleMaintainingTask = setInterval(idleMaintainer, 500, self);\n        }\n\n        ensurePoolSize(self);\n      }\n    }).catch(function (err) {\n      connectionInCreation = false;\n      var task = taskQueue.shift();\n\n      if (task) {\n        firstTaskTimeout = clearTimeout(firstTaskTimeout);\n        process.nextTick(task.reject, err);\n        resetTimeoutToNextTask();\n      } else if (!closed) {\n        console.error(err);\n      }\n\n      ensurePoolSize(self);\n    });\n  };\n\n  this.escape = function (value) {\n    return Utils.escape(options.connOptions, searchInfo(), value);\n  };\n\n  this.escapeId = function (value) {\n    return Utils.escapeId(options.connOptions, searchInfo(), value);\n  }; //*****************************************************************\n  // internal methods\n  //*****************************************************************\n\n  /**\n   * Search info object of an existing connection. to know server type and version.\n   * @returns information object if connection available.\n   */\n\n\n  var searchInfo = function searchInfo() {\n    var info = null;\n    var conn = idleConnections.get(0);\n\n    if (conn == null) {\n      conn = Object.keys(activeConnections)[0];\n    }\n\n    if (conn != null) {\n      info = conn.info;\n    }\n\n    return info;\n  };\n  /**\n   * Get a connection from pool / execute query\n   *\n   * @param pool      current pool\n   * @param sql       sql value (not mandatory)\n   * @param values    sql parameter (not mandatory)\n   * @param isBatch   is batch request\n   * @return {*}\n   */\n\n\n  var addRequest = function addRequest(pool, sql, values, isBatch) {\n    if (closed) {\n      return Promise.reject(Errors.createError('pool is closed', false, null, 'HY000', Errors.ER_POOL_ALREADY_CLOSED, undefined, false));\n    }\n\n    return getIdleValidConnection(pool).then(function (conn) {\n      pool.emit('acquire', conn);\n      return processTask(conn, sql, values, isBatch);\n    }, function () {\n      process.nextTick(function () {\n        return pool.emit('enqueue');\n      }); //no idle connection available\n      //create a new connection if limit is not reached\n\n      ensurePoolSize(pool); //connections are all used, stack demand.\n\n      return new Promise(function (resolve, reject) {\n        var task = {\n          timeout: Date.now() + opts.acquireTimeout,\n          reject: reject,\n          resolve: resolve,\n          sql: sql,\n          values: values,\n          isBatch: isBatch\n        };\n\n        if (!firstTaskTimeout) {\n          firstTaskTimeout = setTimeout(rejectAndResetTimeout, opts.acquireTimeout, task);\n        }\n\n        taskQueue.push(task);\n      });\n    });\n  };\n  /**\n   * Return an idle Connection.\n   * If connection has not been used for some time ( minDelayValidation), validate connection status.\n   *\n   * @param pool pool\n   * @returns {Promise<Connection|null>)} connection of null of no valid idle connection.\n   */\n\n\n  var getIdleValidConnection = function getIdleValidConnection(pool) {\n    if (idleConnections.isEmpty()) {\n      return Promise.reject(null);\n    }\n\n    var conn = idleConnections.shift();\n    activeConnections[conn.threadId] = conn;\n\n    if (opts.minDelayValidation <= 0 || Date.now() - conn.lastUse > opts.minDelayValidation) {\n      return pingPromise(conn).then(function () {\n        initLeakProcess(conn);\n        return Promise.resolve(conn);\n      }).catch(function (err) {\n        delete activeConnections[conn.threadId];\n        pool.emit('_remove-conn');\n        return getIdleValidConnection(pool);\n      });\n    } else {\n      //just check connection state\n      if (conn.isValid()) {\n        initLeakProcess(conn);\n        return Promise.resolve(conn);\n      } else {\n        delete activeConnections[conn.threadId];\n        pool.emit('_remove-conn');\n        return getIdleValidConnection(pool);\n      }\n    }\n  };\n  /**\n   * Task request timeout handler\n   * @param task\n   */\n\n\n  var timeoutTask = function timeoutTask(task) {\n    firstTaskTimeout = null;\n\n    if (task === taskQueue.peekFront()) {\n      taskQueue.shift();\n      process.nextTick(task.reject, Errors.createError('retrieve connection from pool timeout after ' + Math.abs(Date.now() - (task.timeout - opts.acquireTimeout)) + 'ms', false, null, 'HY000', Errors.ER_GET_CONNECTION_TIMEOUT, undefined, false));\n    } else {\n      throw new Error('Rejection by timeout without task !!!');\n    }\n  };\n  /**\n   * Reject task, and reset timeout to next waiting task if any.\n   * @param task\n   */\n\n\n  var rejectAndResetTimeout = function rejectAndResetTimeout(task) {\n    timeoutTask(task);\n    resetTimeoutToNextTask();\n  };\n  /**\n   * Loop for connection creation.\n   * This permits to wait before next try after a connection fail.\n   *\n   * @param pool            current pool\n   * @param iteration       current iteration\n   * @param timeoutEnd      ending timeout\n   * @returns {Promise<any>} Connection if found, error if not\n   */\n\n\n  var connectionCreationLoop = function connectionCreationLoop(pool, iteration, timeoutEnd) {\n    return new Promise(function (resolve, reject) {\n      var creationTryout = function creationTryout(resolve, reject) {\n        if (closed) {\n          reject(Errors.createError('Cannot create new connection to pool, pool closed', true, null, '08S01', Errors.ER_ADD_CONNECTION_CLOSED_POOL, null));\n          return;\n        }\n\n        iteration++;\n        createConnectionPool(pool).then(function (conn) {\n          resolve(conn);\n        }).catch(function (err) {\n          //if timeout is reached or authentication fail return error\n          if (closed || err.errno && (err.errno === 1524 || err.errno === 1045 || err.errno === 1698) || timeoutEnd < Date.now()) {\n            reject(err);\n            return;\n          }\n\n          setTimeout(creationTryout.bind(null, resolve, reject), 500);\n        });\n      }; //initial without timeout\n\n\n      creationTryout(resolve, reject);\n    });\n  };\n\n  var addPoolConnection = function addPoolConnection(pool, conn) {\n    conn.lastUse = Date.now();\n    var initialDestroyFct = conn.destroy;\n\n    conn.destroy = function () {\n      removeLeakProcess(conn);\n      delete activeConnections[conn.threadId];\n      initialDestroyFct();\n      pool.emit('_remove-conn');\n    }; //Connection error\n    // -> evict connection from pool\n\n\n    conn.on('error', function (err) {\n      var idx = 0;\n      var currConn;\n      removeLeakProcess(conn);\n      delete activeConnections[conn.threadId];\n\n      while (currConn = idleConnections.peekAt(idx)) {\n        if (currConn === conn) {\n          idleConnections.removeOne(idx);\n          break;\n        } else {\n          //since connection did have an error, other waiting connection might too\n          //forcing validation when borrowed next time, even if \"minDelayValidation\" is not reached.\n          currConn.lastUse = Math.min(Date.now() - opts.minDelayValidation, currConn.lastUse);\n        }\n\n        idx++;\n      }\n\n      pool.emit('_remove-conn');\n    });\n    connectionInCreation = false;\n    idleConnections.push(conn);\n    pool.emit('_idle-conn');\n    process.nextTick(function () {\n      return pool.emit('connection', conn);\n    });\n  };\n\n  this._releaseConnection = function (conn) {\n    removeLeakProcess(conn);\n    conn.lastUse = Date.now();\n    delete activeConnections[conn.threadId];\n    var pool = this;\n\n    if (closed) {\n      return conn.forceEnd().catch(function () {\n        return Promise.resolve();\n      });\n    } else if (conn.isValid()) {\n      pool.emit('release', conn);\n      idleConnections.push(conn);\n      process.nextTick(function () {\n        return pool.emit('_idle-conn');\n      });\n    } else {\n      ensurePoolSize(pool);\n    }\n  };\n  /**\n   * Grow pool connections until reaching connection limit.\n   */\n\n\n  var ensurePoolSize = function ensurePoolSize(pool) {\n    if (!connectionInCreation && pool.idleConnections() < opts.minimumIdle && pool.totalConnections() < opts.connectionLimit && !closed) {\n      connectionInCreation = true;\n      process.nextTick(function () {\n        var timeoutEnd = Date.now() + opts.initializationTimeout;\n\n        if (!closed) {\n          connectionCreationLoop(pool, 0, timeoutEnd).then(function (conn) {\n            if (closed) {\n              return conn.forceEnd().catch(function (err) {});\n            }\n\n            addPoolConnection(pool, conn);\n          }).catch(function (err) {\n            if (pool.totalConnections() === 0) {\n              var task = taskQueue.shift();\n\n              if (task) {\n                firstTaskTimeout = clearTimeout(firstTaskTimeout);\n                process.nextTick(task.reject, err);\n                resetTimeoutToNextTask();\n              }\n            } else if (!closed) {\n              console.error(\"pool fail to create connection (\".concat(err.message, \")\"));\n            } //delay next try\n\n\n            setTimeout(function () {\n              connectionInCreation = false;\n\n              if (taskQueue.size() > 0) {\n                ensurePoolSize(pool);\n              }\n            }, 500);\n          });\n        }\n      });\n    }\n  };\n\n  var resetTimeoutToNextTask = function resetTimeoutToNextTask() {\n    //handle next Timer\n    var currTime = Date.now();\n    var nextTask;\n\n    while (nextTask = taskQueue.peekFront()) {\n      if (nextTask.timeout < currTime) {\n        timeoutTask(nextTask);\n      } else {\n        firstTaskTimeout = setTimeout(rejectAndResetTimeout, nextTask.timeout - currTime, nextTask);\n        return;\n      }\n    }\n  };\n  /**\n   * Permit to remove idle connection if unused for some time.\n   * @param pool  current pool\n   */\n\n\n  var idleMaintainer = function idleMaintainer(pool) {\n    var toRemove = Math.max(1, pool.idleConnections() - opts.minimumIdle);\n\n    while (toRemove > 0) {\n      var conn = idleConnections.peek();\n      --toRemove;\n\n      if (conn && conn.lastUse + opts.idleTimeout * 1000 < Date.now()) {\n        idleConnections.shift();\n        conn.forceEnd().catch(function (err) {});\n        continue;\n      }\n\n      break;\n    }\n\n    ensurePoolSize(pool);\n  };\n\n  this._discardConnection = function (conn) {\n    removeLeakProcess(conn);\n    delete activeConnections[conn.threadId];\n    conn.forceEnd().catch(function (err) {});\n\n    _this.emit('_remove-conn');\n  };\n\n  var logLeak = function logLeak(conn) {\n    console.log('Possible connection leak on thread ' + conn.info.threadId + ' (connection not returned to pool since ' + (Date.now() - conn.lastUse) + 'ms. Did connection.released() been implemented');\n    conn.leaked = true;\n  };\n\n  var _initLeakProcess = function _initLeakProcess(conn) {\n    conn.lastUse = Date.now();\n    conn.leaked = false;\n    conn.leakProcess = setTimeout(logLeak, opts.leakDetectionTimeout, conn);\n  };\n\n  var _removeLeakProcess = function _removeLeakProcess(conn) {\n    conn.leakProcess = clearTimeout(conn.leakProcess);\n\n    if (conn.leaked) {\n      console.log('Previous possible leak connection with thread ' + conn.info.threadId + ' was returned to pool');\n    }\n  };\n  /**\n   * Launch next waiting task request if available connections.\n   */\n\n\n  var handleTaskQueue = function handleTaskQueue() {\n    firstTaskTimeout = clearTimeout(firstTaskTimeout);\n    var task = taskQueue.shift();\n\n    if (task) {\n      var conn = idleConnections.shift();\n\n      if (conn) {\n        initLeakProcess(conn);\n        this.emit('acquire', conn);\n        activeConnections[conn.threadId] = conn;\n        resetTimeoutToNextTask();\n        processTask(conn, task.sql, task.values, task.isBatch).then(task.resolve).catch(task.reject);\n      } else {\n        taskQueue.unshift(task);\n      }\n    }\n  };\n\n  var opts = options;\n  var closed = false;\n  var connectionInCreation = false;\n  var initLeakProcess = opts.leakDetectionTimeout > 0 ? _initLeakProcess : function () {};\n  var removeLeakProcess = opts.leakDetectionTimeout > 0 ? _removeLeakProcess : function () {};\n  var idleConnections = new Queue();\n  var activeConnections = {};\n  var taskQueue = new Queue();\n  var idleMaintainingTask;\n  var firstTaskTimeout;\n  Object.defineProperty(this, 'closed', {\n    get: function get() {\n      return closed;\n    }\n  });\n  EventEmitter.call(this);\n  this.on('_idle-conn', handleTaskQueue.bind(this));\n  this.on('_remove-conn', ensurePoolSize.bind(this, this));\n  this.on('connection', ensurePoolSize.bind(this, this));\n}\n\nutil.inherits(PoolBase, EventEmitter);\nmodule.exports = PoolBase;","map":{"version":3,"sources":["C:/Users/dembr/Documents/GitHub/react_projects/react-urol-database/node_modules/mariadb/lib/pool-base.js"],"names":["EventEmitter","require","util","Queue","Errors","Utils","PoolBase","options","processTask","createConnectionPool","pingPromise","getConnection","addRequest","query","sql","value","batch","end","closed","Promise","reject","createError","ER_POOL_ALREADY_CLOSED","undefined","clearInterval","idleMaintainingTask","idleConnectionsEndings","conn","idleConnections","shift","push","forceEnd","firstTaskTimeout","clearTimeout","taskQueue","size","task","err","ER_CLOSING_POOL","process","nextTick","all","activeConnections","Object","keys","length","totalConnections","taskQueueSize","initialize","connectionInCreation","self","timeoutEnd","Date","now","opts","initializationTimeout","connectionCreationLoop","then","catch","addPoolConnection","idleTimeout","setInterval","idleMaintainer","ensurePoolSize","resetTimeoutToNextTask","console","error","escape","connOptions","searchInfo","escapeId","info","get","pool","values","isBatch","getIdleValidConnection","emit","resolve","timeout","acquireTimeout","setTimeout","rejectAndResetTimeout","isEmpty","threadId","minDelayValidation","lastUse","initLeakProcess","isValid","timeoutTask","peekFront","Math","abs","ER_GET_CONNECTION_TIMEOUT","Error","iteration","creationTryout","ER_ADD_CONNECTION_CLOSED_POOL","errno","bind","initialDestroyFct","destroy","removeLeakProcess","on","idx","currConn","peekAt","removeOne","min","_releaseConnection","minimumIdle","connectionLimit","message","currTime","nextTask","toRemove","max","peek","_discardConnection","logLeak","log","leaked","_initLeakProcess","leakProcess","leakDetectionTimeout","_removeLeakProcess","handleTaskQueue","unshift","defineProperty","call","inherits","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst util = require('util');\nconst Queue = require('denque');\nconst Errors = require('./misc/errors');\nconst Utils = require('./misc/utils');\n\nfunction PoolBase(options, processTask, createConnectionPool, pingPromise) {\n  //*****************************************************************\n  // public methods\n  //*****************************************************************\n\n  /**\n   * Retrieve a connection from pool.\n   * Create a new one, if limit is not reached.\n   * wait until acquireTimeout.\n   *\n   * @return {Promise}\n   */\n  this.getConnection = function() {\n    return addRequest(this);\n  };\n\n  /**\n   * Execute a query on one connection from pool.\n   *\n   * @param sql   sql command\n   * @param value parameter value of sql command (not mandatory)\n   * @return {Promise}\n   */\n  this.query = function(sql, value) {\n    return addRequest(this, sql, value, false);\n  };\n\n  /**\n   * Execute a batch on one connection from pool.\n   *\n   * @param sql   sql command\n   * @param value parameter value of sql command (not mandatory)\n   * @return {Promise}\n   */\n  this.batch = function(sql, value) {\n    return addRequest(this, sql, value, true);\n  };\n\n  /**\n   * Close all connection in pool\n   *\n   * @return Promise\n   */\n  this.end = function() {\n    if (closed) {\n      return Promise.reject(\n        Errors.createError(\n          'pool is already closed',\n          false,\n          null,\n          'HY000',\n          Errors.ER_POOL_ALREADY_CLOSED,\n          undefined,\n          false\n        )\n      );\n    }\n    closed = true;\n    clearInterval(idleMaintainingTask);\n\n    //close unused connections\n    const idleConnectionsEndings = [];\n    let conn;\n    while ((conn = idleConnections.shift())) {\n      idleConnectionsEndings.push(conn.forceEnd());\n    }\n\n    firstTaskTimeout = clearTimeout(firstTaskTimeout);\n\n    //reject all waiting task\n    if (taskQueue.size() > 0) {\n      let task;\n      const err = Errors.createError(\n        'pool is ending, connection request aborted',\n        false,\n        null,\n        'HY000',\n        Errors.ER_CLOSING_POOL,\n        undefined,\n        false\n      );\n      while ((task = taskQueue.shift())) {\n        process.nextTick(task.reject, err);\n      }\n    }\n\n    return Promise.all(idleConnectionsEndings);\n  };\n\n  /**\n   * Get current active connections.\n   * @return {number}\n   */\n  this.activeConnections = function() {\n    return Object.keys(activeConnections).length;\n  };\n\n  /**\n   * Get current total connection number.\n   * @return {number}\n   */\n  this.totalConnections = function() {\n    return this.activeConnections() + this.idleConnections();\n  };\n\n  /**\n   * Get current idle connection number.\n   * @return {number}\n   */\n  this.idleConnections = function() {\n    return idleConnections.size();\n  };\n\n  /**\n   * Get current stacked connection request.\n   * @return {number}\n   */\n  this.taskQueueSize = function() {\n    return taskQueue.size();\n  };\n\n  /**\n   * First connection creation.\n   * activation is slightly different than pooling grow : If connection fails, there is many retries for 30s\n   * (option initializationTimeout).\n   * If connection fails, error will be thrown to request / console if no request, to ensure that error is thrown.\n   */\n  this.initialize = function() {\n    connectionInCreation = true;\n    const self = this;\n    const timeoutEnd = Date.now() + opts.initializationTimeout;\n    connectionCreationLoop(self, 0, timeoutEnd)\n      .then(conn => {\n        //add to pool\n        if (closed) {\n          conn.forceEnd().catch(err => {});\n        } else {\n          addPoolConnection(self, conn);\n          if (opts.idleTimeout > 0) {\n            idleMaintainingTask = setInterval(idleMaintainer, 500, self);\n          }\n          ensurePoolSize(self);\n        }\n      })\n      .catch(err => {\n        connectionInCreation = false;\n        const task = taskQueue.shift();\n        if (task) {\n          firstTaskTimeout = clearTimeout(firstTaskTimeout);\n          process.nextTick(task.reject, err);\n          resetTimeoutToNextTask();\n        } else if (!closed) {\n          console.error(err);\n        }\n        ensurePoolSize(self);\n      });\n  };\n\n  this.escape = value => {\n    return Utils.escape(options.connOptions, searchInfo(), value);\n  };\n\n  this.escapeId = value => {\n    return Utils.escapeId(options.connOptions, searchInfo(), value);\n  };\n\n  //*****************************************************************\n  // internal methods\n  //*****************************************************************\n\n  /**\n   * Search info object of an existing connection. to know server type and version.\n   * @returns information object if connection available.\n   */\n  const searchInfo = () => {\n    let info = null;\n    let conn = idleConnections.get(0);\n\n    if (conn == null) {\n      conn = Object.keys(activeConnections)[0];\n    }\n\n    if (conn != null) {\n      info = conn.info;\n    }\n    return info;\n  };\n\n  /**\n   * Get a connection from pool / execute query\n   *\n   * @param pool      current pool\n   * @param sql       sql value (not mandatory)\n   * @param values    sql parameter (not mandatory)\n   * @param isBatch   is batch request\n   * @return {*}\n   */\n  const addRequest = function(pool, sql, values, isBatch) {\n    if (closed) {\n      return Promise.reject(\n        Errors.createError(\n          'pool is closed',\n          false,\n          null,\n          'HY000',\n          Errors.ER_POOL_ALREADY_CLOSED,\n          undefined,\n          false\n        )\n      );\n    }\n\n    return getIdleValidConnection(pool).then(\n      conn => {\n        pool.emit('acquire', conn);\n        return processTask(conn, sql, values, isBatch);\n      },\n      () => {\n        process.nextTick(() => pool.emit('enqueue'));\n\n        //no idle connection available\n        //create a new connection if limit is not reached\n        ensurePoolSize(pool);\n\n        //connections are all used, stack demand.\n        return new Promise((resolve, reject) => {\n          const task = {\n            timeout: Date.now() + opts.acquireTimeout,\n            reject: reject,\n            resolve: resolve,\n            sql: sql,\n            values: values,\n            isBatch: isBatch\n          };\n          if (!firstTaskTimeout) {\n            firstTaskTimeout = setTimeout(rejectAndResetTimeout, opts.acquireTimeout, task);\n          }\n          taskQueue.push(task);\n        });\n      }\n    );\n  };\n\n  /**\n   * Return an idle Connection.\n   * If connection has not been used for some time ( minDelayValidation), validate connection status.\n   *\n   * @param pool pool\n   * @returns {Promise<Connection|null>)} connection of null of no valid idle connection.\n   */\n  const getIdleValidConnection = function(pool) {\n    if (idleConnections.isEmpty()) {\n      return Promise.reject(null);\n    }\n    const conn = idleConnections.shift();\n    activeConnections[conn.threadId] = conn;\n    if (opts.minDelayValidation <= 0 || Date.now() - conn.lastUse > opts.minDelayValidation) {\n      return pingPromise(conn)\n        .then(() => {\n          initLeakProcess(conn);\n          return Promise.resolve(conn);\n        })\n        .catch(err => {\n          delete activeConnections[conn.threadId];\n          pool.emit('_remove-conn');\n          return getIdleValidConnection(pool);\n        });\n    } else {\n      //just check connection state\n      if (conn.isValid()) {\n        initLeakProcess(conn);\n        return Promise.resolve(conn);\n      } else {\n        delete activeConnections[conn.threadId];\n        pool.emit('_remove-conn');\n        return getIdleValidConnection(pool);\n      }\n    }\n  };\n\n  /**\n   * Task request timeout handler\n   * @param task\n   */\n  const timeoutTask = task => {\n    firstTaskTimeout = null;\n    if (task === taskQueue.peekFront()) {\n      taskQueue.shift();\n      process.nextTick(\n        task.reject,\n        Errors.createError(\n          'retrieve connection from pool timeout after ' +\n            Math.abs(Date.now() - (task.timeout - opts.acquireTimeout)) +\n            'ms',\n          false,\n          null,\n          'HY000',\n          Errors.ER_GET_CONNECTION_TIMEOUT,\n          undefined,\n          false\n        )\n      );\n    } else {\n      throw new Error('Rejection by timeout without task !!!');\n    }\n  };\n\n  /**\n   * Reject task, and reset timeout to next waiting task if any.\n   * @param task\n   */\n  const rejectAndResetTimeout = task => {\n    timeoutTask(task);\n    resetTimeoutToNextTask();\n  };\n\n  /**\n   * Loop for connection creation.\n   * This permits to wait before next try after a connection fail.\n   *\n   * @param pool            current pool\n   * @param iteration       current iteration\n   * @param timeoutEnd      ending timeout\n   * @returns {Promise<any>} Connection if found, error if not\n   */\n  const connectionCreationLoop = function(pool, iteration, timeoutEnd) {\n    return new Promise(function(resolve, reject) {\n      const creationTryout = function(resolve, reject) {\n        if (closed) {\n          reject(\n            Errors.createError(\n              'Cannot create new connection to pool, pool closed',\n              true,\n              null,\n              '08S01',\n              Errors.ER_ADD_CONNECTION_CLOSED_POOL,\n              null\n            )\n          );\n          return;\n        }\n        iteration++;\n        createConnectionPool(pool)\n          .then(conn => {\n            resolve(conn);\n          })\n          .catch(err => {\n            //if timeout is reached or authentication fail return error\n            if (\n              closed ||\n              (err.errno && (err.errno === 1524 || err.errno === 1045 || err.errno === 1698)) ||\n              timeoutEnd < Date.now()\n            ) {\n              reject(err);\n              return;\n            }\n\n            setTimeout(creationTryout.bind(null, resolve, reject), 500);\n          });\n      };\n      //initial without timeout\n      creationTryout(resolve, reject);\n    });\n  };\n\n  const addPoolConnection = function(pool, conn) {\n    conn.lastUse = Date.now();\n    const initialDestroyFct = conn.destroy;\n    conn.destroy = () => {\n      removeLeakProcess(conn);\n      delete activeConnections[conn.threadId];\n      initialDestroyFct();\n      pool.emit('_remove-conn');\n    };\n\n    //Connection error\n    // -> evict connection from pool\n    conn.on('error', err => {\n      let idx = 0;\n      let currConn;\n      removeLeakProcess(conn);\n      delete activeConnections[conn.threadId];\n      while ((currConn = idleConnections.peekAt(idx))) {\n        if (currConn === conn) {\n          idleConnections.removeOne(idx);\n          break;\n        } else {\n          //since connection did have an error, other waiting connection might too\n          //forcing validation when borrowed next time, even if \"minDelayValidation\" is not reached.\n          currConn.lastUse = Math.min(Date.now() - opts.minDelayValidation, currConn.lastUse);\n        }\n        idx++;\n      }\n      pool.emit('_remove-conn');\n    });\n    connectionInCreation = false;\n    idleConnections.push(conn);\n    pool.emit('_idle-conn');\n    process.nextTick(() => pool.emit('connection', conn));\n  };\n\n  this._releaseConnection = function(conn) {\n    removeLeakProcess(conn);\n    conn.lastUse = Date.now();\n    delete activeConnections[conn.threadId];\n    const pool = this;\n    if (closed) {\n      return conn.forceEnd().catch(() => {\n        return Promise.resolve();\n      });\n    } else if (conn.isValid()) {\n      pool.emit('release', conn);\n      idleConnections.push(conn);\n      process.nextTick(() => pool.emit('_idle-conn'));\n    } else {\n      ensurePoolSize(pool);\n    }\n  };\n\n  /**\n   * Grow pool connections until reaching connection limit.\n   */\n  const ensurePoolSize = function(pool) {\n    if (\n      !connectionInCreation &&\n      pool.idleConnections() < opts.minimumIdle &&\n      pool.totalConnections() < opts.connectionLimit &&\n      !closed\n    ) {\n      connectionInCreation = true;\n      process.nextTick(() => {\n        const timeoutEnd = Date.now() + opts.initializationTimeout;\n        if (!closed) {\n          connectionCreationLoop(pool, 0, timeoutEnd)\n            .then(conn => {\n              if (closed) {\n                return conn.forceEnd().catch(err => {});\n              }\n              addPoolConnection(pool, conn);\n            })\n            .catch(err => {\n              if (pool.totalConnections() === 0) {\n                const task = taskQueue.shift();\n                if (task) {\n                  firstTaskTimeout = clearTimeout(firstTaskTimeout);\n                  process.nextTick(task.reject, err);\n                  resetTimeoutToNextTask();\n                }\n              } else if (!closed) {\n                console.error(`pool fail to create connection (${err.message})`);\n              }\n\n              //delay next try\n              setTimeout(() => {\n                connectionInCreation = false;\n                if (taskQueue.size() > 0) {\n                  ensurePoolSize(pool);\n                }\n              }, 500);\n            });\n        }\n      });\n    }\n  };\n\n  const resetTimeoutToNextTask = () => {\n    //handle next Timer\n    const currTime = Date.now();\n    let nextTask;\n    while ((nextTask = taskQueue.peekFront())) {\n      if (nextTask.timeout < currTime) {\n        timeoutTask(nextTask);\n      } else {\n        firstTaskTimeout = setTimeout(rejectAndResetTimeout, nextTask.timeout - currTime, nextTask);\n        return;\n      }\n    }\n  };\n\n  /**\n   * Permit to remove idle connection if unused for some time.\n   * @param pool  current pool\n   */\n  const idleMaintainer = function(pool) {\n    let toRemove = Math.max(1, pool.idleConnections() - opts.minimumIdle);\n    while (toRemove > 0) {\n      const conn = idleConnections.peek();\n      --toRemove;\n      if (conn && conn.lastUse + opts.idleTimeout * 1000 < Date.now()) {\n        idleConnections.shift();\n        conn.forceEnd().catch(err => {});\n        continue;\n      }\n      break;\n    }\n    ensurePoolSize(pool);\n  };\n\n  this._discardConnection = conn => {\n    removeLeakProcess(conn);\n    delete activeConnections[conn.threadId];\n    conn.forceEnd().catch(err => {});\n    this.emit('_remove-conn');\n  };\n\n  const logLeak = conn => {\n    console.log(\n      'Possible connection leak on thread ' +\n        conn.info.threadId +\n        ' (connection not returned to pool since ' +\n        (Date.now() - conn.lastUse) +\n        'ms. Did connection.released() been implemented'\n    );\n    conn.leaked = true;\n  };\n\n  const _initLeakProcess = conn => {\n    conn.lastUse = Date.now();\n    conn.leaked = false;\n    conn.leakProcess = setTimeout(logLeak, opts.leakDetectionTimeout, conn);\n  };\n\n  const _removeLeakProcess = conn => {\n    conn.leakProcess = clearTimeout(conn.leakProcess);\n    if (conn.leaked) {\n      console.log(\n        'Previous possible leak connection with thread ' +\n          conn.info.threadId +\n          ' was returned to pool'\n      );\n    }\n  };\n\n  /**\n   * Launch next waiting task request if available connections.\n   */\n  const handleTaskQueue = function() {\n    firstTaskTimeout = clearTimeout(firstTaskTimeout);\n    const task = taskQueue.shift();\n\n    if (task) {\n      const conn = idleConnections.shift();\n      if (conn) {\n        initLeakProcess(conn);\n        this.emit('acquire', conn);\n        activeConnections[conn.threadId] = conn;\n        resetTimeoutToNextTask();\n        processTask(conn, task.sql, task.values, task.isBatch)\n          .then(task.resolve)\n          .catch(task.reject);\n      } else {\n        taskQueue.unshift(task);\n      }\n    }\n  };\n\n  const opts = options;\n  let closed = false;\n  let connectionInCreation = false;\n  const initLeakProcess = opts.leakDetectionTimeout > 0 ? _initLeakProcess : () => {};\n  const removeLeakProcess = opts.leakDetectionTimeout > 0 ? _removeLeakProcess : () => {};\n  const idleConnections = new Queue();\n  const activeConnections = {};\n  const taskQueue = new Queue();\n  let idleMaintainingTask;\n  let firstTaskTimeout;\n  Object.defineProperty(this, 'closed', {\n    get() {\n      return closed;\n    }\n  });\n\n  EventEmitter.call(this);\n\n  this.on('_idle-conn', handleTaskQueue.bind(this));\n  this.on('_remove-conn', ensurePoolSize.bind(this, this));\n  this.on('connection', ensurePoolSize.bind(this, this));\n}\n\nutil.inherits(PoolBase, EventEmitter);\nmodule.exports = PoolBase;\n"]},"metadata":{},"sourceType":"script"}