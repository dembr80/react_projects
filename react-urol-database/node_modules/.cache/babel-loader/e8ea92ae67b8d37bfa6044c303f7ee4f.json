{"ast":null,"code":"'use strict';\n\nvar PoolClusterOptions = require('./config/pool-cluster-options');\n\nvar PoolOptions = require('./config/pool-options');\n\nvar Pool = require('./pool-promise');\n\nvar PoolCallback = require('./pool-callback');\n\nvar FilteredPoolCluster = require('./filtered-pool-cluster');\n\nvar EventEmitter = require('events');\n\nvar util = require('util');\n/**\n * Create a new Cluster.\n * Cluster handle pools with patterns and handle failover / distributed load\n * according to selectors (round robin / random / ordered )\n *\n * @param args      cluster argurments. see pool-cluster-options.\n * @constructor\n */\n\n\nfunction PoolCluster(args) {\n  var _this = this;\n\n  var opts = new PoolClusterOptions(args);\n  var nodes = {};\n  var cachedPatterns = {};\n  var nodeCounter = 0;\n  EventEmitter.call(this);\n  /**\n   * Add a new pool node to cluster.\n   *\n   * @param id      identifier\n   * @param config  pool configuration\n   */\n\n  this.add = function (id, config) {\n    var identifier;\n\n    if (typeof id === 'string' || id instanceof String) {\n      identifier = id;\n      if (nodes[identifier]) throw new Error(\"Node identifier '\" + identifier + \"' already exist !\");\n    } else {\n      identifier = 'PoolNode-' + nodeCounter++;\n      config = id;\n    }\n\n    var options = new PoolOptions(config);\n\n    var pool = _createPool(options);\n\n    pool.initialize();\n    nodes[identifier] = pool;\n  };\n  /**\n   * End cluster (and underlying pools).\n   *\n   * @return {Promise<any[]>}\n   */\n\n\n  this.end = function () {\n    cachedPatterns = {};\n    var poolEndPromise = [];\n    Object.keys(nodes).forEach(function (pool) {\n      poolEndPromise.push(nodes[pool].end());\n      delete nodes[pool];\n    });\n    return Promise.all(poolEndPromise);\n  };\n\n  this.of = function (pattern, selector) {\n    return new FilteredPoolCluster(_this, pattern, selector);\n  };\n  /**\n   * Remove nodes according to pattern.\n   *\n   * @param pattern  pattern\n   */\n\n\n  this.remove = function (pattern) {\n    if (!pattern) throw new Error('pattern parameter in Cluster.remove(pattern)  is mandatory');\n    var regex = RegExp(pattern);\n    Object.keys(nodes).forEach(function (key) {\n      if (regex.test(key)) {\n        nodes[key].end();\n        delete nodes[key];\n        cachedPatterns = {};\n      }\n    });\n  };\n  /**\n   * Get connection from available pools matching pattern, according to selector\n   *\n   * @param pattern       pattern filter (not mandatory)\n   * @param selector      node selector ('RR','RANDOM' or 'ORDER')\n   * @return {Promise}\n   */\n\n\n  this.getConnection = function (pattern, selector) {\n    return _getConnection(_this, pattern, selector);\n  };\n  /**\n   * Force using callback methods.\n   */\n\n\n  this.setCallback = function () {\n    _this.getConnection = _getConnectionCallback.bind(_this, _this);\n    _createPool = _createPoolCallback;\n  };\n  /**\n   * Get connection from available pools matching pattern, according to selector\n   * with additional parameter to avoid reusing failing node\n   *\n   * @param pattern       pattern filter (not mandatory)\n   * @param selector      node selector ('RR','RANDOM' or 'ORDER')\n   * @param avoidNodeKey  failing node\n   * @param lastError     last error\n   * @return {Promise}\n   * @private\n   */\n\n\n  var _getConnection = function _getConnection(cluster, pattern, selector, avoidNodeKey, lastError) {\n    var matchingNodeList = _matchingNodes(pattern || /^/);\n\n    if (matchingNodeList.length === 0) {\n      if (Object.keys(nodes).length === 0 && !lastError) {\n        return Promise.reject(new Error('No node have been added to cluster ' + 'or nodes have been removed due to too much connection error'));\n      }\n\n      if (avoidNodeKey === undefined) return Promise.reject(new Error(\"No node found for pattern '\" + pattern + \"'\"));\n      var errMsg = \"No Connection available for '\" + pattern + \"'\" + (lastError ? '. Last connection error was: ' + lastError.message : '');\n      return Promise.reject(new Error(errMsg));\n    }\n\n    var retry = _getConnection.bind(_this, _this, pattern, selector);\n\n    try {\n      var nodeKey = _selectPool(matchingNodeList, selector, avoidNodeKey);\n\n      return _handleConnectionError(cluster, matchingNodeList, nodeKey, retry);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  var _createPool = function _createPool(options) {\n    return new Pool(options, false);\n  };\n\n  var _createPoolCallback = function _createPoolCallback(options) {\n    return new PoolCallback(options, false);\n  };\n  /**\n   * Get connection from available pools matching pattern, according to selector\n   * with additional parameter to avoid reusing failing node\n   *\n   * @param pattern       pattern filter (not mandatory)\n   * @param selector      node selector ('RR','RANDOM' or 'ORDER')\n   * @param callback      callback function\n   * @param avoidNodeKey  failing node\n   * @param lastError     last error\n   * @private\n   */\n\n\n  var _getConnectionCallback = function _getConnectionCallback(cluster, pattern, selector, callback, avoidNodeKey, lastError) {\n    var matchingNodeList = _matchingNodes(pattern || /^/);\n\n    if (matchingNodeList.length === 0) {\n      if (Object.keys(nodes).length === 0 && !lastError) {\n        callback(new Error('No node have been added to cluster ' + 'or nodes have been removed due to too much connection error'));\n        return;\n      }\n\n      if (avoidNodeKey === undefined) callback(new Error(\"No node found for pattern '\" + pattern + \"'\"));\n      var errMsg = \"No Connection available for '\" + pattern + \"'\" + (lastError ? '. Last connection error was: ' + lastError.message : '');\n      callback(new Error(errMsg));\n      return;\n    }\n\n    var retry = _getConnectionCallback.bind(_this, _this, pattern, selector, callback);\n\n    try {\n      var nodeKey = _selectPool(matchingNodeList, selector, avoidNodeKey);\n\n      _handleConnectionCallbackError(_this, matchingNodeList, nodeKey, retry, callback);\n    } catch (e) {\n      callback(e);\n    }\n  };\n  /**\n   * Selecting nodes according to pattern.\n   *\n   * @param pattern pattern\n   * @return {*}\n   * @private\n   */\n\n\n  var _matchingNodes = function _matchingNodes(pattern) {\n    if (cachedPatterns[pattern]) return cachedPatterns[pattern];\n    var regex = RegExp(pattern);\n    var matchingNodeList = [];\n    Object.keys(nodes).forEach(function (key) {\n      if (regex.test(key)) {\n        matchingNodeList.push(key);\n      }\n    });\n    cachedPatterns[pattern] = matchingNodeList;\n    return matchingNodeList;\n  };\n  /**\n   * Select next node to be chosen in nodeList according to selector and failed nodes.\n   *\n   * @param nodeList        current node list\n   * @param selectorParam   selector\n   * @param avoidNodeKey    last failing node to avoid selecting this one.\n   * @return {Promise}\n   * @private\n   */\n\n\n  var _selectPool = function _selectPool(nodeList, selectorParam, avoidNodeKey) {\n    var selector = selectorParam || opts.defaultSelector;\n    var retry = 0;\n    var selectorFct;\n    var nodeKey;\n\n    switch (selector) {\n      case 'RR':\n        selectorFct = roundRobinSelector;\n        break;\n\n      case 'RANDOM':\n        selectorFct = randomSelector;\n        break;\n\n      case 'ORDER':\n        selectorFct = orderedSelector;\n        break;\n\n      default:\n        throw new Error(\"Wrong selector value '\" + selector + \"'. Possible values are 'RR','RANDOM' or 'ORDER'\");\n    }\n\n    nodeKey = selectorFct(nodeList, retry);\n\n    while ((avoidNodeKey === nodeKey || nodes[nodeKey].blacklistedUntil > Date.now()) && retry < nodeList.length - 1) {\n      retry++;\n      nodeKey = selectorFct(nodeList, retry);\n    }\n\n    return nodeKey;\n  };\n  /**\n   * Round robin selector: using nodes one after the other.\n   *\n   * @param nodeList  node list\n   * @return {String}\n   */\n\n\n  var roundRobinSelector = function roundRobinSelector(nodeList) {\n    var lastRoundRobin = nodeList.lastRrIdx;\n    if (lastRoundRobin === undefined) lastRoundRobin = -1;\n    if (++lastRoundRobin >= nodeList.length) lastRoundRobin = 0;\n    nodeList.lastRrIdx = lastRoundRobin;\n    return nodeList[lastRoundRobin];\n  };\n  /**\n   * Random selector: use a random node.\n   *\n   * @param nodeList  node list\n   * @return {String}\n   */\n\n\n  var randomSelector = function randomSelector(nodeList) {\n    var randomIdx = Math.floor(Math.random() * nodeList.length);\n    return nodeList[randomIdx];\n  };\n  /**\n   * Ordered selector: always use the nodes in sequence, unless failing.\n   *\n   * @param nodeList  node list\n   * @param retry     sequence number if last node is tagged has failing\n   * @return {String}\n   */\n\n\n  var orderedSelector = function orderedSelector(nodeList, retry) {\n    return nodeList[retry];\n  };\n  /**\n   * Connect, or if fail handle retry / set timeout error\n   *\n   * @param cluster     current cluster\n   * @param nodeList    current node list\n   * @param nodeKey     node name to connect\n   * @param retryFct    retry function\n   * @return {Promise}\n   * @private\n   */\n\n\n  var _handleConnectionError = function _handleConnectionError(cluster, nodeList, nodeKey, retryFct) {\n    var node = nodes[nodeKey];\n    return node.getConnection().then(function (conn) {\n      node.errorCount = 0;\n      return Promise.resolve(conn);\n    }).catch(function (err) {\n      node.errorCount = node.errorCount ? node.errorCount + 1 : 1;\n      node.blacklistedUntil = Date.now() + opts.restoreNodeTimeout;\n\n      if (opts.removeNodeErrorCount && node.errorCount >= opts.removeNodeErrorCount && nodes[nodeKey]) {\n        delete nodes[nodeKey];\n        cachedPatterns = {};\n        delete nodeList.lastRrIdx;\n        process.nextTick(function () {\n          return cluster.emit('remove', nodeKey);\n        }); //remove node from configuration if not already removed\n\n        node.end().catch(function (err) {// dismiss error\n        });\n      }\n\n      if (nodeList.length !== 0 && opts.canRetry) {\n        return retryFct(nodeKey, err);\n      }\n\n      return Promise.reject(err);\n    });\n  };\n  /**\n   * Connect, or if fail handle retry / set timeout error\n   *\n   * @param cluster     current cluster\n   * @param nodeList    current node list\n   * @param nodeKey     node name to connect\n   * @param retryFct    retry function\n   * @param callback    callback function\n   * @private\n   */\n\n\n  var _handleConnectionCallbackError = function _handleConnectionCallbackError(cluster, nodeList, nodeKey, retryFct, callback) {\n    var node = nodes[nodeKey];\n    node.getConnection(function (err, conn) {\n      if (err) {\n        node.errorCount = node.errorCount ? node.errorCount + 1 : 1;\n        node.blacklistedUntil = Date.now() + opts.restoreNodeTimeout;\n\n        if (opts.removeNodeErrorCount && node.errorCount >= opts.removeNodeErrorCount && nodes[nodeKey]) {\n          delete nodes[nodeKey];\n          cachedPatterns = {};\n          delete nodeList.lastRrIdx;\n          process.nextTick(function () {\n            return cluster.emit('remove', nodeKey);\n          }); //remove node from configuration if not already removed\n\n          node.end(function () {//dismiss error\n          });\n          if (nodeList.length === 0) return Promise.reject(err);\n        }\n\n        if (opts.canRetry) return retryFct(nodeKey, err);\n        callback(err);\n      } else {\n        node.errorCount = 0;\n        callback(null, conn);\n      }\n    });\n  }; //*****************************************************************\n  // internal public testing methods\n  //*****************************************************************\n\n\n  function TestMethods() {}\n\n  TestMethods.prototype.getNodes = function () {\n    return nodes;\n  };\n\n  this.__tests = new TestMethods();\n}\n\nutil.inherits(PoolCluster, EventEmitter);\nmodule.exports = PoolCluster;","map":{"version":3,"sources":["C:/Users/dembr/Documents/GitHub/react_projects/react-urol-database/node_modules/mariadb/lib/pool-cluster.js"],"names":["PoolClusterOptions","require","PoolOptions","Pool","PoolCallback","FilteredPoolCluster","EventEmitter","util","PoolCluster","args","opts","nodes","cachedPatterns","nodeCounter","call","add","id","config","identifier","String","Error","options","pool","_createPool","initialize","end","poolEndPromise","Object","keys","forEach","push","Promise","all","of","pattern","selector","remove","regex","RegExp","key","test","getConnection","_getConnection","setCallback","_getConnectionCallback","bind","_createPoolCallback","cluster","avoidNodeKey","lastError","matchingNodeList","_matchingNodes","length","reject","undefined","errMsg","message","retry","nodeKey","_selectPool","_handleConnectionError","e","callback","_handleConnectionCallbackError","nodeList","selectorParam","defaultSelector","selectorFct","roundRobinSelector","randomSelector","orderedSelector","blacklistedUntil","Date","now","lastRoundRobin","lastRrIdx","randomIdx","Math","floor","random","retryFct","node","then","conn","errorCount","resolve","catch","err","restoreNodeTimeout","removeNodeErrorCount","process","nextTick","emit","canRetry","TestMethods","prototype","getNodes","__tests","inherits","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst PoolClusterOptions = require('./config/pool-cluster-options');\nconst PoolOptions = require('./config/pool-options');\nconst Pool = require('./pool-promise');\nconst PoolCallback = require('./pool-callback');\nconst FilteredPoolCluster = require('./filtered-pool-cluster');\nconst EventEmitter = require('events');\nconst util = require('util');\n\n/**\n * Create a new Cluster.\n * Cluster handle pools with patterns and handle failover / distributed load\n * according to selectors (round robin / random / ordered )\n *\n * @param args      cluster argurments. see pool-cluster-options.\n * @constructor\n */\nfunction PoolCluster(args) {\n  const opts = new PoolClusterOptions(args);\n  const nodes = {};\n  let cachedPatterns = {};\n  let nodeCounter = 0;\n  EventEmitter.call(this);\n\n  /**\n   * Add a new pool node to cluster.\n   *\n   * @param id      identifier\n   * @param config  pool configuration\n   */\n  this.add = (id, config) => {\n    let identifier;\n    if (typeof id === 'string' || id instanceof String) {\n      identifier = id;\n      if (nodes[identifier])\n        throw new Error(\"Node identifier '\" + identifier + \"' already exist !\");\n    } else {\n      identifier = 'PoolNode-' + nodeCounter++;\n      config = id;\n    }\n    const options = new PoolOptions(config);\n    const pool = _createPool(options);\n    pool.initialize();\n    nodes[identifier] = pool;\n  };\n\n  /**\n   * End cluster (and underlying pools).\n   *\n   * @return {Promise<any[]>}\n   */\n  this.end = () => {\n    cachedPatterns = {};\n    const poolEndPromise = [];\n    Object.keys(nodes).forEach(pool => {\n      poolEndPromise.push(nodes[pool].end());\n      delete nodes[pool];\n    });\n\n    return Promise.all(poolEndPromise);\n  };\n\n  this.of = (pattern, selector) => {\n    return new FilteredPoolCluster(this, pattern, selector);\n  };\n\n  /**\n   * Remove nodes according to pattern.\n   *\n   * @param pattern  pattern\n   */\n  this.remove = pattern => {\n    if (!pattern) throw new Error('pattern parameter in Cluster.remove(pattern)  is mandatory');\n\n    const regex = RegExp(pattern);\n    Object.keys(nodes).forEach(key => {\n      if (regex.test(key)) {\n        nodes[key].end();\n        delete nodes[key];\n        cachedPatterns = {};\n      }\n    });\n  };\n\n  /**\n   * Get connection from available pools matching pattern, according to selector\n   *\n   * @param pattern       pattern filter (not mandatory)\n   * @param selector      node selector ('RR','RANDOM' or 'ORDER')\n   * @return {Promise}\n   */\n  this.getConnection = (pattern, selector) => {\n    return _getConnection(this, pattern, selector);\n  };\n\n  /**\n   * Force using callback methods.\n   */\n  this.setCallback = () => {\n    this.getConnection = _getConnectionCallback.bind(this, this);\n    _createPool = _createPoolCallback;\n  };\n\n  /**\n   * Get connection from available pools matching pattern, according to selector\n   * with additional parameter to avoid reusing failing node\n   *\n   * @param pattern       pattern filter (not mandatory)\n   * @param selector      node selector ('RR','RANDOM' or 'ORDER')\n   * @param avoidNodeKey  failing node\n   * @param lastError     last error\n   * @return {Promise}\n   * @private\n   */\n  const _getConnection = (cluster, pattern, selector, avoidNodeKey, lastError) => {\n    const matchingNodeList = _matchingNodes(pattern || /^/);\n\n    if (matchingNodeList.length === 0) {\n      if (Object.keys(nodes).length === 0 && !lastError) {\n        return Promise.reject(\n          new Error(\n            'No node have been added to cluster ' +\n              'or nodes have been removed due to too much connection error'\n          )\n        );\n      }\n      if (avoidNodeKey === undefined)\n        return Promise.reject(new Error(\"No node found for pattern '\" + pattern + \"'\"));\n      const errMsg =\n        \"No Connection available for '\" +\n        pattern +\n        \"'\" +\n        (lastError ? '. Last connection error was: ' + lastError.message : '');\n      return Promise.reject(new Error(errMsg));\n    }\n\n    const retry = _getConnection.bind(this, this, pattern, selector);\n    try {\n      const nodeKey = _selectPool(matchingNodeList, selector, avoidNodeKey);\n      return _handleConnectionError(cluster, matchingNodeList, nodeKey, retry);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  let _createPool = options => {\n    return new Pool(options, false);\n  };\n\n  const _createPoolCallback = options => {\n    return new PoolCallback(options, false);\n  };\n\n  /**\n   * Get connection from available pools matching pattern, according to selector\n   * with additional parameter to avoid reusing failing node\n   *\n   * @param pattern       pattern filter (not mandatory)\n   * @param selector      node selector ('RR','RANDOM' or 'ORDER')\n   * @param callback      callback function\n   * @param avoidNodeKey  failing node\n   * @param lastError     last error\n   * @private\n   */\n  const _getConnectionCallback = (\n    cluster,\n    pattern,\n    selector,\n    callback,\n    avoidNodeKey,\n    lastError\n  ) => {\n    const matchingNodeList = _matchingNodes(pattern || /^/);\n\n    if (matchingNodeList.length === 0) {\n      if (Object.keys(nodes).length === 0 && !lastError) {\n        callback(\n          new Error(\n            'No node have been added to cluster ' +\n              'or nodes have been removed due to too much connection error'\n          )\n        );\n        return;\n      }\n\n      if (avoidNodeKey === undefined)\n        callback(new Error(\"No node found for pattern '\" + pattern + \"'\"));\n      const errMsg =\n        \"No Connection available for '\" +\n        pattern +\n        \"'\" +\n        (lastError ? '. Last connection error was: ' + lastError.message : '');\n      callback(new Error(errMsg));\n      return;\n    }\n\n    const retry = _getConnectionCallback.bind(this, this, pattern, selector, callback);\n    try {\n      const nodeKey = _selectPool(matchingNodeList, selector, avoidNodeKey);\n      _handleConnectionCallbackError(this, matchingNodeList, nodeKey, retry, callback);\n    } catch (e) {\n      callback(e);\n    }\n  };\n\n  /**\n   * Selecting nodes according to pattern.\n   *\n   * @param pattern pattern\n   * @return {*}\n   * @private\n   */\n  const _matchingNodes = pattern => {\n    if (cachedPatterns[pattern]) return cachedPatterns[pattern];\n\n    const regex = RegExp(pattern);\n    const matchingNodeList = [];\n    Object.keys(nodes).forEach(key => {\n      if (regex.test(key)) {\n        matchingNodeList.push(key);\n      }\n    });\n\n    cachedPatterns[pattern] = matchingNodeList;\n    return matchingNodeList;\n  };\n\n  /**\n   * Select next node to be chosen in nodeList according to selector and failed nodes.\n   *\n   * @param nodeList        current node list\n   * @param selectorParam   selector\n   * @param avoidNodeKey    last failing node to avoid selecting this one.\n   * @return {Promise}\n   * @private\n   */\n  const _selectPool = (nodeList, selectorParam, avoidNodeKey) => {\n    const selector = selectorParam || opts.defaultSelector;\n    let retry = 0;\n    let selectorFct;\n    let nodeKey;\n    switch (selector) {\n      case 'RR':\n        selectorFct = roundRobinSelector;\n        break;\n\n      case 'RANDOM':\n        selectorFct = randomSelector;\n        break;\n\n      case 'ORDER':\n        selectorFct = orderedSelector;\n        break;\n\n      default:\n        throw new Error(\n          \"Wrong selector value '\" + selector + \"'. Possible values are 'RR','RANDOM' or 'ORDER'\"\n        );\n    }\n\n    nodeKey = selectorFct(nodeList, retry);\n    while (\n      (avoidNodeKey === nodeKey || nodes[nodeKey].blacklistedUntil > Date.now()) &&\n      retry < nodeList.length - 1\n    ) {\n      retry++;\n      nodeKey = selectorFct(nodeList, retry);\n    }\n    return nodeKey;\n  };\n\n  /**\n   * Round robin selector: using nodes one after the other.\n   *\n   * @param nodeList  node list\n   * @return {String}\n   */\n  const roundRobinSelector = nodeList => {\n    let lastRoundRobin = nodeList.lastRrIdx;\n    if (lastRoundRobin === undefined) lastRoundRobin = -1;\n    if (++lastRoundRobin >= nodeList.length) lastRoundRobin = 0;\n    nodeList.lastRrIdx = lastRoundRobin;\n    return nodeList[lastRoundRobin];\n  };\n\n  /**\n   * Random selector: use a random node.\n   *\n   * @param nodeList  node list\n   * @return {String}\n   */\n  const randomSelector = nodeList => {\n    let randomIdx = Math.floor(Math.random() * nodeList.length);\n    return nodeList[randomIdx];\n  };\n\n  /**\n   * Ordered selector: always use the nodes in sequence, unless failing.\n   *\n   * @param nodeList  node list\n   * @param retry     sequence number if last node is tagged has failing\n   * @return {String}\n   */\n  const orderedSelector = (nodeList, retry) => {\n    return nodeList[retry];\n  };\n\n  /**\n   * Connect, or if fail handle retry / set timeout error\n   *\n   * @param cluster     current cluster\n   * @param nodeList    current node list\n   * @param nodeKey     node name to connect\n   * @param retryFct    retry function\n   * @return {Promise}\n   * @private\n   */\n  const _handleConnectionError = (cluster, nodeList, nodeKey, retryFct) => {\n    const node = nodes[nodeKey];\n    return node\n      .getConnection()\n      .then(conn => {\n        node.errorCount = 0;\n        return Promise.resolve(conn);\n      })\n      .catch(err => {\n        node.errorCount = node.errorCount ? node.errorCount + 1 : 1;\n        node.blacklistedUntil = Date.now() + opts.restoreNodeTimeout;\n        if (\n          opts.removeNodeErrorCount &&\n          node.errorCount >= opts.removeNodeErrorCount &&\n          nodes[nodeKey]\n        ) {\n          delete nodes[nodeKey];\n          cachedPatterns = {};\n          delete nodeList.lastRrIdx;\n          process.nextTick(() => cluster.emit('remove', nodeKey));\n          //remove node from configuration if not already removed\n          node.end().catch(err => {\n            // dismiss error\n          });\n        }\n\n        if (nodeList.length !== 0 && opts.canRetry) {\n          return retryFct(nodeKey, err);\n        }\n        return Promise.reject(err);\n      });\n  };\n\n  /**\n   * Connect, or if fail handle retry / set timeout error\n   *\n   * @param cluster     current cluster\n   * @param nodeList    current node list\n   * @param nodeKey     node name to connect\n   * @param retryFct    retry function\n   * @param callback    callback function\n   * @private\n   */\n  const _handleConnectionCallbackError = (cluster, nodeList, nodeKey, retryFct, callback) => {\n    const node = nodes[nodeKey];\n    node.getConnection((err, conn) => {\n      if (err) {\n        node.errorCount = node.errorCount ? node.errorCount + 1 : 1;\n        node.blacklistedUntil = Date.now() + opts.restoreNodeTimeout;\n        if (\n          opts.removeNodeErrorCount &&\n          node.errorCount >= opts.removeNodeErrorCount &&\n          nodes[nodeKey]\n        ) {\n          delete nodes[nodeKey];\n          cachedPatterns = {};\n          delete nodeList.lastRrIdx;\n          process.nextTick(() => cluster.emit('remove', nodeKey));\n          //remove node from configuration if not already removed\n          node.end(() => {\n            //dismiss error\n          });\n          if (nodeList.length === 0) return Promise.reject(err);\n        }\n\n        if (opts.canRetry) return retryFct(nodeKey, err);\n        callback(err);\n      } else {\n        node.errorCount = 0;\n        callback(null, conn);\n      }\n    });\n  };\n\n  //*****************************************************************\n  // internal public testing methods\n  //*****************************************************************\n\n  function TestMethods() {}\n  TestMethods.prototype.getNodes = () => {\n    return nodes;\n  };\n\n  this.__tests = new TestMethods();\n}\n\nutil.inherits(PoolCluster, EventEmitter);\n\nmodule.exports = PoolCluster;\n"]},"metadata":{},"sourceType":"script"}