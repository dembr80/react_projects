{"ast":null,"code":"'use strict';\n\nvar PoolCluster = require('./pool-cluster');\n\nvar util = require('util');\n/**\n * Create a new Cluster.\n * Cluster handle pools with patterns and handle failover / distributed load\n * according to selectors (round robin / random / ordered )\n *\n * @param args      cluster argurments. see pool-cluster-options.\n * @constructor\n */\n\n\nfunction PoolClusterCallback(args) {\n  PoolCluster.call(this, args);\n  this.setCallback();\n  var initialGetConnection = this.getConnection.bind(this);\n  var initialEnd = this.end.bind(this);\n  /**\n   * End cluster (and underlying pools).\n   *\n   * @param callback - not mandatory\n   */\n\n  this.end = function (callback) {\n    if (callback && typeof callback !== 'function') {\n      throw new Error('callback parameter must be a function');\n    }\n\n    var endingFct = callback ? callback : function () {};\n    initialEnd().then(function () {\n      endingFct();\n    }).catch(endingFct);\n  };\n  /**\n   * Get connection from available pools matching pattern, according to selector\n   *\n   * @param pattern       pattern filter (not mandatory)\n   * @param selector      node selector ('RR','RANDOM' or 'ORDER')\n   * @param callback      callback function\n   */\n\n\n  this.getConnection = function (pattern, selector, callback) {\n    var pat = pattern,\n        sel = selector,\n        cal = callback;\n\n    if (typeof pattern === 'function') {\n      pat = null;\n      sel = null;\n      cal = pattern;\n    } else if (typeof selector === 'function') {\n      sel = null;\n      cal = selector;\n    }\n\n    var endingFct = cal ? cal : function (conn) {};\n    initialGetConnection(pat, sel, endingFct);\n  };\n}\n\nutil.inherits(PoolClusterCallback, PoolCluster);\nmodule.exports = PoolClusterCallback;","map":{"version":3,"sources":["C:/Users/dembr/Documents/GitHub/react_projects/react-urol-database/node_modules/mariadb/lib/pool-cluster-callback.js"],"names":["PoolCluster","require","util","PoolClusterCallback","args","call","setCallback","initialGetConnection","getConnection","bind","initialEnd","end","callback","Error","endingFct","then","catch","pattern","selector","pat","sel","cal","conn","inherits","module","exports"],"mappings":"AAAA;;AAEA,IAAMA,WAAW,GAAGC,OAAO,CAAC,gBAAD,CAA3B;;AACA,IAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;AAEA;;;;;;;;;;AAQA,SAASE,mBAAT,CAA6BC,IAA7B,EAAmC;AACjCJ,EAAAA,WAAW,CAACK,IAAZ,CAAiB,IAAjB,EAAuBD,IAAvB;AACA,OAAKE,WAAL;AAEA,MAAMC,oBAAoB,GAAG,KAAKC,aAAL,CAAmBC,IAAnB,CAAwB,IAAxB,CAA7B;AACA,MAAMC,UAAU,GAAG,KAAKC,GAAL,CAASF,IAAT,CAAc,IAAd,CAAnB;AAEA;;;;;;AAKA,OAAKE,GAAL,GAAW,UAAAC,QAAQ,EAAI;AACrB,QAAIA,QAAQ,IAAI,OAAOA,QAAP,KAAoB,UAApC,EAAgD;AAC9C,YAAM,IAAIC,KAAJ,CAAU,uCAAV,CAAN;AACD;;AACD,QAAMC,SAAS,GAAGF,QAAQ,GAAGA,QAAH,GAAc,YAAM,CAAE,CAAhD;AAEAF,IAAAA,UAAU,GACPK,IADH,CACQ,YAAM;AACVD,MAAAA,SAAS;AACV,KAHH,EAIGE,KAJH,CAISF,SAJT;AAKD,GAXD;AAaA;;;;;;;;;AAOA,OAAKN,aAAL,GAAqB,UAACS,OAAD,EAAUC,QAAV,EAAoBN,QAApB,EAAiC;AACpD,QAAIO,GAAG,GAAGF,OAAV;AAAA,QACEG,GAAG,GAAGF,QADR;AAAA,QAEEG,GAAG,GAAGT,QAFR;;AAGA,QAAI,OAAOK,OAAP,KAAmB,UAAvB,EAAmC;AACjCE,MAAAA,GAAG,GAAG,IAAN;AACAC,MAAAA,GAAG,GAAG,IAAN;AACAC,MAAAA,GAAG,GAAGJ,OAAN;AACD,KAJD,MAIO,IAAI,OAAOC,QAAP,KAAoB,UAAxB,EAAoC;AACzCE,MAAAA,GAAG,GAAG,IAAN;AACAC,MAAAA,GAAG,GAAGH,QAAN;AACD;;AACD,QAAMJ,SAAS,GAAGO,GAAG,GAAGA,GAAH,GAAS,UAAAC,IAAI,EAAI,CAAE,CAAxC;AAEAf,IAAAA,oBAAoB,CAACY,GAAD,EAAMC,GAAN,EAAWN,SAAX,CAApB;AACD,GAfD;AAgBD;;AAEDZ,IAAI,CAACqB,QAAL,CAAcpB,mBAAd,EAAmCH,WAAnC;AAEAwB,MAAM,CAACC,OAAP,GAAiBtB,mBAAjB","sourcesContent":["'use strict';\n\nconst PoolCluster = require('./pool-cluster');\nconst util = require('util');\n\n/**\n * Create a new Cluster.\n * Cluster handle pools with patterns and handle failover / distributed load\n * according to selectors (round robin / random / ordered )\n *\n * @param args      cluster argurments. see pool-cluster-options.\n * @constructor\n */\nfunction PoolClusterCallback(args) {\n  PoolCluster.call(this, args);\n  this.setCallback();\n\n  const initialGetConnection = this.getConnection.bind(this);\n  const initialEnd = this.end.bind(this);\n\n  /**\n   * End cluster (and underlying pools).\n   *\n   * @param callback - not mandatory\n   */\n  this.end = callback => {\n    if (callback && typeof callback !== 'function') {\n      throw new Error('callback parameter must be a function');\n    }\n    const endingFct = callback ? callback : () => {};\n\n    initialEnd()\n      .then(() => {\n        endingFct();\n      })\n      .catch(endingFct);\n  };\n\n  /**\n   * Get connection from available pools matching pattern, according to selector\n   *\n   * @param pattern       pattern filter (not mandatory)\n   * @param selector      node selector ('RR','RANDOM' or 'ORDER')\n   * @param callback      callback function\n   */\n  this.getConnection = (pattern, selector, callback) => {\n    let pat = pattern,\n      sel = selector,\n      cal = callback;\n    if (typeof pattern === 'function') {\n      pat = null;\n      sel = null;\n      cal = pattern;\n    } else if (typeof selector === 'function') {\n      sel = null;\n      cal = selector;\n    }\n    const endingFct = cal ? cal : conn => {};\n\n    initialGetConnection(pat, sel, endingFct);\n  };\n}\n\nutil.inherits(PoolClusterCallback, PoolCluster);\n\nmodule.exports = PoolClusterCallback;\n"]},"metadata":{},"sourceType":"script"}