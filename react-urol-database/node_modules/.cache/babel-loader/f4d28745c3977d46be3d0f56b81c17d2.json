{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\dembr\\\\Documents\\\\GitHub\\\\react_projects\\\\react-urol-database\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\dembr\\\\Documents\\\\GitHub\\\\react_projects\\\\react-urol-database\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar Iconv = require('iconv-lite');\n\nvar Utils = require('../misc/utils');\n\nvar QUOTE = 0x27;\nvar DBL_QUOTE = 0x22;\nvar ZERO_BYTE = 0x00;\nvar SLASH = 0x5c; //increase by level to avoid buffer copy.\n\nvar SMALL_BUFFER_SIZE = 1024;\nvar MEDIUM_BUFFER_SIZE = 16384; //16k\n\nvar LARGE_BUFFER_SIZE = 131072; //128k\n\nvar BIG_BUFFER_SIZE = 1048576; //1M\n\nvar MAX_BUFFER_SIZE = 16777219; //16M + 4\n\nvar CHARS_GLOBAL_REGEXP = /[\\0\\\"\\'\\\\\\b\\n\\r\\t\\u001A]/g; // eslint-disable-line no-control-regex\n\n/**\n * MySQL packet builder.\n *\n * @param opts    options\n * @param info    connection info\n * @constructor\n */\n\nvar PacketOutputStream =\n/*#__PURE__*/\nfunction () {\n  function PacketOutputStream(opts, info) {\n    _classCallCheck(this, PacketOutputStream);\n\n    this.opts = opts;\n    this.info = info;\n    this.pos = 4;\n    this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n    this.changeEncoding(this.opts.collation);\n    this.changeDebug(this.opts.logPackets, this.opts.debug);\n    this.opts.on('collation', this.changeEncoding.bind(this));\n    this.opts.on('debug', this.changeDebug.bind(this));\n  }\n\n  _createClass(PacketOutputStream, [{\n    key: \"changeEncoding\",\n    value: function changeEncoding(collation) {\n      this.encoding = collation.charset;\n\n      if (this.encoding === 'utf8') {\n        this.writeString = this.writeDefaultBufferString;\n        this.writeStringEscapeQuote = this.writeUtf8StringEscapeQuote;\n      } else if (Buffer.isEncoding(this.encoding)) {\n        this.writeString = this.writeDefaultBufferString;\n        this.writeStringEscapeQuote = this.writeDefaultStringEscapeQuote;\n      } else {\n        this.writeString = this.writeDefaultIconvString;\n        this.writeStringEscapeQuote = this.writeDefaultStringEscapeQuote;\n      }\n    }\n  }, {\n    key: \"changeDebug\",\n    value: function changeDebug(logPackets, debug) {\n      this.logPackets = logPackets;\n      this.debug = debug;\n      this.flushBuffer = this.logPackets || this.debug ? this.flushBufferDebug : this.flushBufferBasic;\n    }\n  }, {\n    key: \"setStream\",\n    value: function setStream(stream) {\n      this.stream = stream;\n    }\n  }, {\n    key: \"growBuffer\",\n    value: function growBuffer(len) {\n      var newCapacity;\n\n      if (len + this.pos < MEDIUM_BUFFER_SIZE) {\n        newCapacity = MEDIUM_BUFFER_SIZE;\n      } else if (len + this.pos < LARGE_BUFFER_SIZE) {\n        newCapacity = LARGE_BUFFER_SIZE;\n      } else if (len + this.pos < BIG_BUFFER_SIZE) {\n        newCapacity = BIG_BUFFER_SIZE;\n      } else newCapacity = MAX_BUFFER_SIZE;\n\n      var newBuf = Buffer.allocUnsafe(newCapacity);\n      this.buf.copy(newBuf, 0, 0, this.pos);\n      this.buf = newBuf;\n    }\n  }, {\n    key: \"startPacket\",\n    value: function startPacket(cmd) {\n      this.cmd = cmd;\n      this.pos = 4;\n    }\n  }, {\n    key: \"writeInt8\",\n    value: function writeInt8(value) {\n      if (this.pos + 1 >= this.buf.length) {\n        if (this.pos >= MAX_BUFFER_SIZE) {\n          //buffer is more than a Packet, must flushBuffer()\n          this.flushBuffer(false, 1);\n        } else this.growBuffer(1);\n      }\n\n      this.buf[this.pos++] = value;\n    }\n  }, {\n    key: \"writeInt16\",\n    value: function writeInt16(value) {\n      if (this.pos + 2 >= this.buf.length) {\n        var b = Buffer.allocUnsafe(2);\n        b.writeUInt16LE(value, 0);\n        this.writeBuffer(b, 0, 2);\n        return;\n      }\n\n      this.buf[this.pos] = value;\n      this.buf[this.pos + 1] = value >> 8;\n      this.pos += 2;\n    }\n  }, {\n    key: \"writeInt16AtPos\",\n    value: function writeInt16AtPos(initPos) {\n      this.buf[initPos] = this.pos - initPos - 2;\n      this.buf[initPos + 1] = this.pos - initPos - 2 >> 8;\n    }\n  }, {\n    key: \"writeInt32\",\n    value: function writeInt32(value) {\n      if (this.pos + 4 >= this.buf.length) {\n        //not enough space remaining\n        var arr = Buffer.allocUnsafe(4);\n        arr.writeInt32LE(value, 0);\n        this.writeBuffer(arr, 0, 4);\n        return;\n      }\n\n      this.buf[this.pos] = value;\n      this.buf[this.pos + 1] = value >> 8;\n      this.buf[this.pos + 2] = value >> 16;\n      this.buf[this.pos + 3] = value >> 24;\n      this.pos += 4;\n    }\n  }, {\n    key: \"writeLengthCoded\",\n    value: function writeLengthCoded(len) {\n      //length encoded can be null(0xfb) or bigger than 65k, but only if using binary protocol\n      //so not implemented for now\n      if (len < 0xfb) {\n        this.writeInt8(len);\n        return;\n      } //max length is len < 0xffff\n\n\n      this.writeInt8(0xfc);\n      this.writeInt16(len);\n    }\n  }, {\n    key: \"writeBuffer\",\n    value: function writeBuffer(arr, off, len) {\n      if (len > this.buf.length - this.pos) {\n        if (this.buf.length !== MAX_BUFFER_SIZE) {\n          this.growBuffer(len);\n        } //max buffer size\n\n\n        if (len > this.buf.length - this.pos) {\n          //not enough space in buffer, will stream :\n          // fill buffer and flush until all data are snd\n          var remainingLen = len;\n\n          while (true) {\n            //filling buffer\n            var lenToFillBuffer = Math.min(MAX_BUFFER_SIZE - this.pos, remainingLen);\n            arr.copy(this.buf, this.pos, off, off + lenToFillBuffer);\n            remainingLen -= lenToFillBuffer;\n            off += lenToFillBuffer;\n            this.pos += lenToFillBuffer;\n            if (remainingLen === 0) return;\n            this.flushBuffer(false, remainingLen);\n          }\n        }\n      }\n\n      arr.copy(this.buf, this.pos, off, off + len);\n      this.pos += len;\n    }\n    /**\n     * Write ascii string to socket (no escaping)\n     *\n     * @param str                string\n     */\n\n  }, {\n    key: \"writeStringAscii\",\n    value: function writeStringAscii(str) {\n      var len = str.length; //not enough space remaining\n\n      if (len >= this.buf.length - this.pos) {\n        var strBuf = Buffer.from(str, 'ascii');\n        this.writeBuffer(strBuf, 0, strBuf.length);\n        return;\n      }\n\n      for (var off = 0; off < len;) {\n        this.buf[this.pos++] = str.charCodeAt(off++);\n      }\n    }\n  }, {\n    key: \"writeUtf8StringEscapeQuote\",\n    value: function writeUtf8StringEscapeQuote(str) {\n      var charsLength = str.length; //not enough space remaining\n\n      if (charsLength * 3 + 2 >= this.buf.length - this.pos) {\n        var arr = Buffer.from(str, 'utf8');\n        this.writeInt8(QUOTE);\n        this.writeBufferEscape(arr);\n        this.writeInt8(QUOTE);\n        return;\n      } //create UTF-8 byte array\n      //since javascript char are internally using UTF-16 using surrogate's pattern, 4 bytes unicode characters will\n      //represent 2 characters : example \"\\uD83C\\uDFA4\" = ðŸŽ¤ unicode 8 \"no microphones\"\n      //so max size is 3 * charLength\n      //(escape characters are 1 byte encoded, so length might only be 2 when escaped)\n      // + 2 for the quotes for text protocol\n\n\n      var charsOffset = 0;\n      var currChar;\n      this.buf[this.pos++] = QUOTE; //quick loop if only ASCII chars for faster escape\n\n      for (; charsOffset < charsLength && (currChar = str.charCodeAt(charsOffset)) < 0x80; charsOffset++) {\n        if (currChar === SLASH || currChar === QUOTE || currChar === ZERO_BYTE || currChar === DBL_QUOTE) {\n          this.buf[this.pos++] = SLASH;\n        }\n\n        this.buf[this.pos++] = currChar;\n      } //if quick loop not finished\n\n\n      while (charsOffset < charsLength) {\n        currChar = str.charCodeAt(charsOffset++);\n\n        if (currChar < 0x80) {\n          if (currChar === SLASH || currChar === QUOTE || currChar === ZERO_BYTE || currChar === DBL_QUOTE) {\n            this.buf[this.pos++] = SLASH;\n          }\n\n          this.buf[this.pos++] = currChar;\n        } else if (currChar < 0x800) {\n          this.buf[this.pos++] = 0xc0 | currChar >> 6;\n          this.buf[this.pos++] = 0x80 | currChar & 0x3f;\n        } else if (currChar >= 0xd800 && currChar < 0xe000) {\n          //reserved for surrogate - see https://en.wikipedia.org/wiki/UTF-16\n          if (currChar < 0xdc00) {\n            //is high surrogate\n            if (charsOffset + 1 > charsLength) {\n              this.buf[this.pos++] = 0x3f;\n            } else {\n              var nextChar = str.charCodeAt(charsOffset);\n\n              if (nextChar >= 0xdc00 && nextChar < 0xe000) {\n                //is low surrogate\n                var surrogatePairs = (currChar << 10) + nextChar + (0x010000 - (0xd800 << 10) - 0xdc00);\n                this.buf[this.pos++] = 0xf0 | surrogatePairs >> 18;\n                this.buf[this.pos++] = 0x80 | surrogatePairs >> 12 & 0x3f;\n                this.buf[this.pos++] = 0x80 | surrogatePairs >> 6 & 0x3f;\n                this.buf[this.pos++] = 0x80 | surrogatePairs & 0x3f;\n                charsOffset++;\n              } else {\n                //must have low surrogate\n                this.buf[this.pos++] = 0x3f;\n              }\n            }\n          } else {\n            //low surrogate without high surrogate before\n            this.buf[this.pos++] = 0x3f;\n          }\n        } else {\n          this.buf[this.pos++] = 0xe0 | currChar >> 12;\n          this.buf[this.pos++] = 0x80 | currChar >> 6 & 0x3f;\n          this.buf[this.pos++] = 0x80 | currChar & 0x3f;\n        }\n      }\n\n      this.buf[this.pos++] = QUOTE;\n    }\n  }, {\n    key: \"writeDefaultBufferString\",\n    value: function writeDefaultBufferString(str) {\n      //javascript use UCS-2 or UTF-16 string internal representation\n      //that means that string to byte will be a maximum of * 3\n      // (4 bytes utf-8 are represented on 2 UTF-16 characters)\n      if (str.length * 3 < this.buf.length - this.pos) {\n        this.pos += this.buf.write(str, this.pos, this.encoding);\n        return;\n      } //checking real length\n\n\n      var byteLength = Buffer.byteLength(str, this.encoding);\n\n      if (byteLength > this.buf.length - this.pos) {\n        if (this.buf.length < MAX_BUFFER_SIZE) {\n          this.growBuffer(byteLength);\n        }\n\n        if (byteLength > this.buf.length - this.pos) {\n          //not enough space in buffer, will stream :\n          var strBuf = Buffer.from(str, this.encoding);\n          this.writeBuffer(strBuf, 0, strBuf.length);\n          return;\n        }\n      }\n\n      this.pos += this.buf.write(str, this.pos, this.encoding);\n    }\n  }, {\n    key: \"writeDefaultIconvString\",\n    value: function writeDefaultIconvString(str) {\n      var buf = Iconv.encode(str, this.encoding);\n      this.writeBuffer(buf, 0, buf.length);\n    }\n    /**\n     * Parameters need to be properly escaped :\n     * following characters are to be escaped by \"\\\" :\n     * - \\0\n     * - \\\\\n     * - \\'\n     * - \\\"\n     * regex split part of string writing part, and escaping special char.\n     * Those chars are <= 7f meaning that this will work even with multi-byte encoding\n     *\n     * @param str string to escape.\n     */\n\n  }, {\n    key: \"writeDefaultStringEscapeQuote\",\n    value: function writeDefaultStringEscapeQuote(str) {\n      this.writeInt8(QUOTE);\n      var match;\n      var lastIndex = 0;\n\n      while ((match = CHARS_GLOBAL_REGEXP.exec(str)) !== null) {\n        this.writeString(str.slice(lastIndex, match.index));\n        this.writeInt8(SLASH);\n        this.writeInt8(match[0].charCodeAt(0));\n        lastIndex = CHARS_GLOBAL_REGEXP.lastIndex;\n      }\n\n      if (lastIndex === 0) {\n        // Nothing was escaped\n        this.writeString(str);\n        this.writeInt8(QUOTE);\n        return;\n      }\n\n      if (lastIndex < str.length) {\n        this.writeString(str.slice(lastIndex));\n      }\n\n      this.writeInt8(QUOTE);\n    }\n  }, {\n    key: \"writeBufferEscape\",\n    value: function writeBufferEscape(val) {\n      var valLen = val.length;\n\n      if (valLen * 2 > this.buf.length - this.pos) {\n        //makes buffer bigger (up to 16M)\n        if (this.buf.length !== MAX_BUFFER_SIZE) this.growBuffer(valLen * 2); //data may still be bigger than buffer.\n        //must flush buffer when full (and reset position to 4)\n\n        if (valLen * 2 > this.buf.length - this.pos) {\n          //not enough space in buffer, will fill buffer\n          for (var i = 0; i < valLen; i++) {\n            switch (val[i]) {\n              case QUOTE:\n              case SLASH:\n              case DBL_QUOTE:\n              case ZERO_BYTE:\n                if (this.pos >= this.buf.length) this.flushBuffer(false, (valLen - i) * 2);\n                this.buf[this.pos++] = SLASH;\n              //add escape slash\n            }\n\n            if (this.pos >= this.buf.length) this.flushBuffer(false, (valLen - i) * 2);\n            this.buf[this.pos++] = val[i];\n          }\n\n          return;\n        }\n      } //sure to have enough place to use buffer directly\n\n\n      for (var _i = 0; _i < valLen; _i++) {\n        switch (val[_i]) {\n          case QUOTE:\n          case SLASH:\n          case DBL_QUOTE:\n          case ZERO_BYTE:\n            this.buf[this.pos++] = SLASH;\n          //add escape slash\n        }\n\n        this.buf[this.pos++] = val[_i];\n      }\n    }\n    /**\n     * Indicate if buffer contain any data.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.pos <= 4;\n    }\n    /**\n     * Flush the internal buffer.\n     */\n\n  }, {\n    key: \"flushBufferDebug\",\n    value: function flushBufferDebug(commandEnd, remainingLen) {\n      this.buf[0] = this.pos - 4;\n      this.buf[1] = this.pos - 4 >>> 8;\n      this.buf[2] = this.pos - 4 >>> 16;\n      this.buf[3] = ++this.cmd.sequenceNo;\n      this.stream.writeBuf(this.buf.slice(0, this.pos), this.cmd);\n      var packet = Utils.log(this.opts, this.buf, 0, this.pos);\n\n      if (this.opts.logPackets) {\n        this.info.addPacket('==> conn:' + (this.info.threadId ? this.info.threadId : -1) + ' ' + this.cmd.constructor.name + '(0,' + this.pos + ')\\n' + packet);\n      }\n\n      if (this.opts.debug) {\n        console.log('==> conn:%d %s\\n%s', this.info.threadId ? this.info.threadId : -1, this.cmd.constructor.name + '(0,' + this.pos + ')', Utils.log(this.opts, this.buf, 0, this.pos));\n      }\n\n      if (commandEnd) {\n        //if last packet fill the max size, must send an empty com to indicate that command end.\n        if (this.pos === MAX_BUFFER_SIZE) {\n          this.writeEmptyPacket();\n        } else {\n          this.stream.flush(true, this.cmd);\n          this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n        }\n      } else {\n        this.buf = allocateBuffer(remainingLen + 4);\n        this.pos = 4;\n      }\n    }\n  }, {\n    key: \"flushBufferBasic\",\n    value: function flushBufferBasic(commandEnd, remainingLen) {\n      this.buf[0] = this.pos - 4;\n      this.buf[1] = this.pos - 4 >>> 8;\n      this.buf[2] = this.pos - 4 >>> 16;\n      this.buf[3] = ++this.cmd.sequenceNo;\n      this.stream.writeBuf(this.buf.slice(0, this.pos), this.cmd);\n\n      if (commandEnd) {\n        //if last packet fill the max size, must send an empty com to indicate that command end.\n        if (this.pos === MAX_BUFFER_SIZE) {\n          this.writeEmptyPacket();\n        } else {\n          this.stream.flush(true, this.cmd);\n          this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n        }\n      } else {\n        this.buf = allocateBuffer(remainingLen + 4);\n        this.pos = 4;\n      }\n    }\n  }, {\n    key: \"writeEmptyPacket\",\n    value: function writeEmptyPacket() {\n      var emptyBuf = Buffer.from([0x00, 0x00, 0x00, ++this.cmd.sequenceNo]);\n\n      if (this.opts.logPackets || this.opts.debug) {\n        var packet = Utils.log(this.opts, emptyBuf, 0, 4);\n\n        if (this.opts.logPackets) {\n          this.info.addPacket('==> conn:' + (this.info.threadId ? this.info.threadId : -1) + ' ' + this.cmd.constructor.name + '(0,4)\\n' + packet);\n        }\n\n        if (this.opts.debug) {\n          console.log('==> conn:%d %s\\n%s', this.info.threadId ? this.info.threadId : -1, this.cmd.constructor.name + '(0,4)', packet);\n        }\n      }\n\n      this.stream.writeBuf(emptyBuf, this.cmd);\n      this.stream.flush(true, this.cmd);\n    }\n  }]);\n\n  return PacketOutputStream;\n}();\n\nfunction allocateBuffer(len) {\n  if (len < SMALL_BUFFER_SIZE) {\n    return Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n  } else if (len < MEDIUM_BUFFER_SIZE) {\n    return Buffer.allocUnsafe(MEDIUM_BUFFER_SIZE);\n  } else if (len < LARGE_BUFFER_SIZE) {\n    return Buffer.allocUnsafe(LARGE_BUFFER_SIZE);\n  } else if (len < BIG_BUFFER_SIZE) {\n    return Buffer.allocUnsafe(BIG_BUFFER_SIZE);\n  }\n\n  return Buffer.allocUnsafe(MAX_BUFFER_SIZE);\n}\n\nmodule.exports = PacketOutputStream;","map":{"version":3,"sources":["C:/Users/dembr/Documents/GitHub/react_projects/react-urol-database/node_modules/mariadb/lib/io/packet-output-stream.js"],"names":["Iconv","require","Utils","QUOTE","DBL_QUOTE","ZERO_BYTE","SLASH","SMALL_BUFFER_SIZE","MEDIUM_BUFFER_SIZE","LARGE_BUFFER_SIZE","BIG_BUFFER_SIZE","MAX_BUFFER_SIZE","CHARS_GLOBAL_REGEXP","PacketOutputStream","opts","info","pos","buf","Buffer","allocUnsafe","changeEncoding","collation","changeDebug","logPackets","debug","on","bind","encoding","charset","writeString","writeDefaultBufferString","writeStringEscapeQuote","writeUtf8StringEscapeQuote","isEncoding","writeDefaultStringEscapeQuote","writeDefaultIconvString","flushBuffer","flushBufferDebug","flushBufferBasic","stream","len","newCapacity","newBuf","copy","cmd","value","length","growBuffer","b","writeUInt16LE","writeBuffer","initPos","arr","writeInt32LE","writeInt8","writeInt16","off","remainingLen","lenToFillBuffer","Math","min","str","strBuf","from","charCodeAt","charsLength","writeBufferEscape","charsOffset","currChar","nextChar","surrogatePairs","write","byteLength","encode","match","lastIndex","exec","slice","index","val","valLen","i","commandEnd","sequenceNo","writeBuf","packet","log","addPacket","threadId","constructor","name","console","writeEmptyPacket","flush","allocateBuffer","emptyBuf","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Iconv = require('iconv-lite');\nconst Utils = require('../misc/utils');\n\nconst QUOTE = 0x27;\nconst DBL_QUOTE = 0x22;\nconst ZERO_BYTE = 0x00;\nconst SLASH = 0x5c;\n\n//increase by level to avoid buffer copy.\nconst SMALL_BUFFER_SIZE = 1024;\nconst MEDIUM_BUFFER_SIZE = 16384; //16k\nconst LARGE_BUFFER_SIZE = 131072; //128k\nconst BIG_BUFFER_SIZE = 1048576; //1M\nconst MAX_BUFFER_SIZE = 16777219; //16M + 4\nconst CHARS_GLOBAL_REGEXP = /[\\0\\\"\\'\\\\\\b\\n\\r\\t\\u001A]/g; // eslint-disable-line no-control-regex\n\n/**\n * MySQL packet builder.\n *\n * @param opts    options\n * @param info    connection info\n * @constructor\n */\nclass PacketOutputStream {\n  constructor(opts, info) {\n    this.opts = opts;\n    this.info = info;\n    this.pos = 4;\n    this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n    this.changeEncoding(this.opts.collation);\n    this.changeDebug(this.opts.logPackets, this.opts.debug);\n\n    this.opts.on('collation', this.changeEncoding.bind(this));\n    this.opts.on('debug', this.changeDebug.bind(this));\n  }\n\n  changeEncoding(collation) {\n    this.encoding = collation.charset;\n    if (this.encoding === 'utf8') {\n      this.writeString = this.writeDefaultBufferString;\n      this.writeStringEscapeQuote = this.writeUtf8StringEscapeQuote;\n    } else if (Buffer.isEncoding(this.encoding)) {\n      this.writeString = this.writeDefaultBufferString;\n      this.writeStringEscapeQuote = this.writeDefaultStringEscapeQuote;\n    } else {\n      this.writeString = this.writeDefaultIconvString;\n      this.writeStringEscapeQuote = this.writeDefaultStringEscapeQuote;\n    }\n  }\n\n  changeDebug(logPackets, debug) {\n    this.logPackets = logPackets;\n    this.debug = debug;\n    this.flushBuffer =\n      this.logPackets || this.debug ? this.flushBufferDebug : this.flushBufferBasic;\n  }\n\n  setStream(stream) {\n    this.stream = stream;\n  }\n\n  growBuffer(len) {\n    let newCapacity;\n    if (len + this.pos < MEDIUM_BUFFER_SIZE) {\n      newCapacity = MEDIUM_BUFFER_SIZE;\n    } else if (len + this.pos < LARGE_BUFFER_SIZE) {\n      newCapacity = LARGE_BUFFER_SIZE;\n    } else if (len + this.pos < BIG_BUFFER_SIZE) {\n      newCapacity = BIG_BUFFER_SIZE;\n    } else newCapacity = MAX_BUFFER_SIZE;\n\n    let newBuf = Buffer.allocUnsafe(newCapacity);\n    this.buf.copy(newBuf, 0, 0, this.pos);\n    this.buf = newBuf;\n  }\n\n  startPacket(cmd) {\n    this.cmd = cmd;\n    this.pos = 4;\n  }\n\n  writeInt8(value) {\n    if (this.pos + 1 >= this.buf.length) {\n      if (this.pos >= MAX_BUFFER_SIZE) {\n        //buffer is more than a Packet, must flushBuffer()\n        this.flushBuffer(false, 1);\n      } else this.growBuffer(1);\n    }\n    this.buf[this.pos++] = value;\n  }\n\n  writeInt16(value) {\n    if (this.pos + 2 >= this.buf.length) {\n      let b = Buffer.allocUnsafe(2);\n      b.writeUInt16LE(value, 0);\n      this.writeBuffer(b, 0, 2);\n      return;\n    }\n    this.buf[this.pos] = value;\n    this.buf[this.pos + 1] = value >> 8;\n    this.pos += 2;\n  }\n\n  writeInt16AtPos(initPos) {\n    this.buf[initPos] = this.pos - initPos - 2;\n    this.buf[initPos + 1] = (this.pos - initPos - 2) >> 8;\n  }\n\n  writeInt32(value) {\n    if (this.pos + 4 >= this.buf.length) {\n      //not enough space remaining\n      let arr = Buffer.allocUnsafe(4);\n      arr.writeInt32LE(value, 0);\n      this.writeBuffer(arr, 0, 4);\n      return;\n    }\n\n    this.buf[this.pos] = value;\n    this.buf[this.pos + 1] = value >> 8;\n    this.buf[this.pos + 2] = value >> 16;\n    this.buf[this.pos + 3] = value >> 24;\n    this.pos += 4;\n  }\n\n  writeLengthCoded(len) {\n    //length encoded can be null(0xfb) or bigger than 65k, but only if using binary protocol\n    //so not implemented for now\n    if (len < 0xfb) {\n      this.writeInt8(len);\n      return;\n    }\n\n    //max length is len < 0xffff\n    this.writeInt8(0xfc);\n    this.writeInt16(len);\n  }\n\n  writeBuffer(arr, off, len) {\n    if (len > this.buf.length - this.pos) {\n      if (this.buf.length !== MAX_BUFFER_SIZE) {\n        this.growBuffer(len);\n      }\n\n      //max buffer size\n      if (len > this.buf.length - this.pos) {\n        //not enough space in buffer, will stream :\n        // fill buffer and flush until all data are snd\n        let remainingLen = len;\n\n        while (true) {\n          //filling buffer\n          let lenToFillBuffer = Math.min(MAX_BUFFER_SIZE - this.pos, remainingLen);\n          arr.copy(this.buf, this.pos, off, off + lenToFillBuffer);\n          remainingLen -= lenToFillBuffer;\n          off += lenToFillBuffer;\n          this.pos += lenToFillBuffer;\n\n          if (remainingLen === 0) return;\n          this.flushBuffer(false, remainingLen);\n        }\n      }\n    }\n    arr.copy(this.buf, this.pos, off, off + len);\n    this.pos += len;\n  }\n\n  /**\n   * Write ascii string to socket (no escaping)\n   *\n   * @param str                string\n   */\n  writeStringAscii(str) {\n    let len = str.length;\n\n    //not enough space remaining\n    if (len >= this.buf.length - this.pos) {\n      let strBuf = Buffer.from(str, 'ascii');\n      this.writeBuffer(strBuf, 0, strBuf.length);\n      return;\n    }\n\n    for (let off = 0; off < len; ) {\n      this.buf[this.pos++] = str.charCodeAt(off++);\n    }\n  }\n\n  writeUtf8StringEscapeQuote(str) {\n    const charsLength = str.length;\n\n    //not enough space remaining\n    if (charsLength * 3 + 2 >= this.buf.length - this.pos) {\n      const arr = Buffer.from(str, 'utf8');\n      this.writeInt8(QUOTE);\n      this.writeBufferEscape(arr);\n      this.writeInt8(QUOTE);\n      return;\n    }\n\n    //create UTF-8 byte array\n    //since javascript char are internally using UTF-16 using surrogate's pattern, 4 bytes unicode characters will\n    //represent 2 characters : example \"\\uD83C\\uDFA4\" = ðŸŽ¤ unicode 8 \"no microphones\"\n    //so max size is 3 * charLength\n    //(escape characters are 1 byte encoded, so length might only be 2 when escaped)\n    // + 2 for the quotes for text protocol\n    let charsOffset = 0;\n    let currChar;\n    this.buf[this.pos++] = QUOTE;\n    //quick loop if only ASCII chars for faster escape\n    for (\n      ;\n      charsOffset < charsLength && (currChar = str.charCodeAt(charsOffset)) < 0x80;\n      charsOffset++\n    ) {\n      if (\n        currChar === SLASH ||\n        currChar === QUOTE ||\n        currChar === ZERO_BYTE ||\n        currChar === DBL_QUOTE\n      ) {\n        this.buf[this.pos++] = SLASH;\n      }\n      this.buf[this.pos++] = currChar;\n    }\n\n    //if quick loop not finished\n    while (charsOffset < charsLength) {\n      currChar = str.charCodeAt(charsOffset++);\n      if (currChar < 0x80) {\n        if (\n          currChar === SLASH ||\n          currChar === QUOTE ||\n          currChar === ZERO_BYTE ||\n          currChar === DBL_QUOTE\n        ) {\n          this.buf[this.pos++] = SLASH;\n        }\n        this.buf[this.pos++] = currChar;\n      } else if (currChar < 0x800) {\n        this.buf[this.pos++] = 0xc0 | (currChar >> 6);\n        this.buf[this.pos++] = 0x80 | (currChar & 0x3f);\n      } else if (currChar >= 0xd800 && currChar < 0xe000) {\n        //reserved for surrogate - see https://en.wikipedia.org/wiki/UTF-16\n        if (currChar < 0xdc00) {\n          //is high surrogate\n          if (charsOffset + 1 > charsLength) {\n            this.buf[this.pos++] = 0x3f;\n          } else {\n            const nextChar = str.charCodeAt(charsOffset);\n            if (nextChar >= 0xdc00 && nextChar < 0xe000) {\n              //is low surrogate\n              const surrogatePairs =\n                (currChar << 10) + nextChar + (0x010000 - (0xd800 << 10) - 0xdc00);\n              this.buf[this.pos++] = 0xf0 | (surrogatePairs >> 18);\n              this.buf[this.pos++] = 0x80 | ((surrogatePairs >> 12) & 0x3f);\n              this.buf[this.pos++] = 0x80 | ((surrogatePairs >> 6) & 0x3f);\n              this.buf[this.pos++] = 0x80 | (surrogatePairs & 0x3f);\n              charsOffset++;\n            } else {\n              //must have low surrogate\n              this.buf[this.pos++] = 0x3f;\n            }\n          }\n        } else {\n          //low surrogate without high surrogate before\n          this.buf[this.pos++] = 0x3f;\n        }\n      } else {\n        this.buf[this.pos++] = 0xe0 | (currChar >> 12);\n        this.buf[this.pos++] = 0x80 | ((currChar >> 6) & 0x3f);\n        this.buf[this.pos++] = 0x80 | (currChar & 0x3f);\n      }\n    }\n    this.buf[this.pos++] = QUOTE;\n  }\n\n  writeDefaultBufferString(str) {\n    //javascript use UCS-2 or UTF-16 string internal representation\n    //that means that string to byte will be a maximum of * 3\n    // (4 bytes utf-8 are represented on 2 UTF-16 characters)\n    if (str.length * 3 < this.buf.length - this.pos) {\n      this.pos += this.buf.write(str, this.pos, this.encoding);\n      return;\n    }\n\n    //checking real length\n    let byteLength = Buffer.byteLength(str, this.encoding);\n    if (byteLength > this.buf.length - this.pos) {\n      if (this.buf.length < MAX_BUFFER_SIZE) {\n        this.growBuffer(byteLength);\n      }\n      if (byteLength > this.buf.length - this.pos) {\n        //not enough space in buffer, will stream :\n        let strBuf = Buffer.from(str, this.encoding);\n        this.writeBuffer(strBuf, 0, strBuf.length);\n        return;\n      }\n    }\n    this.pos += this.buf.write(str, this.pos, this.encoding);\n  }\n\n  writeDefaultIconvString(str) {\n    let buf = Iconv.encode(str, this.encoding);\n    this.writeBuffer(buf, 0, buf.length);\n  }\n\n  /**\n   * Parameters need to be properly escaped :\n   * following characters are to be escaped by \"\\\" :\n   * - \\0\n   * - \\\\\n   * - \\'\n   * - \\\"\n   * regex split part of string writing part, and escaping special char.\n   * Those chars are <= 7f meaning that this will work even with multi-byte encoding\n   *\n   * @param str string to escape.\n   */\n  writeDefaultStringEscapeQuote(str) {\n    this.writeInt8(QUOTE);\n    let match;\n    let lastIndex = 0;\n    while ((match = CHARS_GLOBAL_REGEXP.exec(str)) !== null) {\n      this.writeString(str.slice(lastIndex, match.index));\n      this.writeInt8(SLASH);\n      this.writeInt8(match[0].charCodeAt(0));\n      lastIndex = CHARS_GLOBAL_REGEXP.lastIndex;\n    }\n\n    if (lastIndex === 0) {\n      // Nothing was escaped\n      this.writeString(str);\n      this.writeInt8(QUOTE);\n      return;\n    }\n\n    if (lastIndex < str.length) {\n      this.writeString(str.slice(lastIndex));\n    }\n    this.writeInt8(QUOTE);\n  }\n\n  writeBufferEscape(val) {\n    let valLen = val.length;\n    if (valLen * 2 > this.buf.length - this.pos) {\n      //makes buffer bigger (up to 16M)\n      if (this.buf.length !== MAX_BUFFER_SIZE) this.growBuffer(valLen * 2);\n\n      //data may still be bigger than buffer.\n      //must flush buffer when full (and reset position to 4)\n      if (valLen * 2 > this.buf.length - this.pos) {\n        //not enough space in buffer, will fill buffer\n        for (let i = 0; i < valLen; i++) {\n          switch (val[i]) {\n            case QUOTE:\n            case SLASH:\n            case DBL_QUOTE:\n            case ZERO_BYTE:\n              if (this.pos >= this.buf.length) this.flushBuffer(false, (valLen - i) * 2);\n              this.buf[this.pos++] = SLASH; //add escape slash\n          }\n          if (this.pos >= this.buf.length) this.flushBuffer(false, (valLen - i) * 2);\n          this.buf[this.pos++] = val[i];\n        }\n        return;\n      }\n    }\n\n    //sure to have enough place to use buffer directly\n    for (let i = 0; i < valLen; i++) {\n      switch (val[i]) {\n        case QUOTE:\n        case SLASH:\n        case DBL_QUOTE:\n        case ZERO_BYTE:\n          this.buf[this.pos++] = SLASH; //add escape slash\n      }\n      this.buf[this.pos++] = val[i];\n    }\n  }\n\n  /**\n   * Indicate if buffer contain any data.\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this.pos <= 4;\n  }\n\n  /**\n   * Flush the internal buffer.\n   */\n  flushBufferDebug(commandEnd, remainingLen) {\n    this.buf[0] = this.pos - 4;\n    this.buf[1] = (this.pos - 4) >>> 8;\n    this.buf[2] = (this.pos - 4) >>> 16;\n    this.buf[3] = ++this.cmd.sequenceNo;\n\n    this.stream.writeBuf(this.buf.slice(0, this.pos), this.cmd);\n\n    const packet = Utils.log(this.opts, this.buf, 0, this.pos);\n    if (this.opts.logPackets) {\n      this.info.addPacket(\n        '==> conn:' +\n          (this.info.threadId ? this.info.threadId : -1) +\n          ' ' +\n          this.cmd.constructor.name +\n          '(0,' +\n          this.pos +\n          ')\\n' +\n          packet\n      );\n    }\n\n    if (this.opts.debug) {\n      console.log(\n        '==> conn:%d %s\\n%s',\n        this.info.threadId ? this.info.threadId : -1,\n        this.cmd.constructor.name + '(0,' + this.pos + ')',\n        Utils.log(this.opts, this.buf, 0, this.pos)\n      );\n    }\n\n    if (commandEnd) {\n      //if last packet fill the max size, must send an empty com to indicate that command end.\n      if (this.pos === MAX_BUFFER_SIZE) {\n        this.writeEmptyPacket();\n      } else {\n        this.stream.flush(true, this.cmd);\n        this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n      }\n    } else {\n      this.buf = allocateBuffer(remainingLen + 4);\n      this.pos = 4;\n    }\n  }\n\n  flushBufferBasic(commandEnd, remainingLen) {\n    this.buf[0] = this.pos - 4;\n    this.buf[1] = (this.pos - 4) >>> 8;\n    this.buf[2] = (this.pos - 4) >>> 16;\n    this.buf[3] = ++this.cmd.sequenceNo;\n    this.stream.writeBuf(this.buf.slice(0, this.pos), this.cmd);\n    if (commandEnd) {\n      //if last packet fill the max size, must send an empty com to indicate that command end.\n      if (this.pos === MAX_BUFFER_SIZE) {\n        this.writeEmptyPacket();\n      } else {\n        this.stream.flush(true, this.cmd);\n        this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n      }\n    } else {\n      this.buf = allocateBuffer(remainingLen + 4);\n      this.pos = 4;\n    }\n  }\n\n  writeEmptyPacket() {\n    const emptyBuf = Buffer.from([0x00, 0x00, 0x00, ++this.cmd.sequenceNo]);\n\n    if (this.opts.logPackets || this.opts.debug) {\n      const packet = Utils.log(this.opts, emptyBuf, 0, 4);\n      if (this.opts.logPackets) {\n        this.info.addPacket(\n          '==> conn:' +\n            (this.info.threadId ? this.info.threadId : -1) +\n            ' ' +\n            this.cmd.constructor.name +\n            '(0,4)\\n' +\n            packet\n        );\n      }\n      if (this.opts.debug) {\n        console.log(\n          '==> conn:%d %s\\n%s',\n          this.info.threadId ? this.info.threadId : -1,\n          this.cmd.constructor.name + '(0,4)',\n          packet\n        );\n      }\n    }\n\n    this.stream.writeBuf(emptyBuf, this.cmd);\n    this.stream.flush(true, this.cmd);\n  }\n}\n\nfunction allocateBuffer(len) {\n  if (len < SMALL_BUFFER_SIZE) {\n    return Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n  } else if (len < MEDIUM_BUFFER_SIZE) {\n    return Buffer.allocUnsafe(MEDIUM_BUFFER_SIZE);\n  } else if (len < LARGE_BUFFER_SIZE) {\n    return Buffer.allocUnsafe(LARGE_BUFFER_SIZE);\n  } else if (len < BIG_BUFFER_SIZE) {\n    return Buffer.allocUnsafe(BIG_BUFFER_SIZE);\n  }\n  return Buffer.allocUnsafe(MAX_BUFFER_SIZE);\n}\n\nmodule.exports = PacketOutputStream;\n"]},"metadata":{},"sourceType":"script"}