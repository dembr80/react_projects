{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\dembr\\\\Documents\\\\GitHub\\\\react_projects\\\\react-urol-database\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\dembr\\\\Documents\\\\GitHub\\\\react_projects\\\\react-urol-database\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar Errors = require('../misc/errors');\n\nvar Iconv = require('iconv-lite');\n\nvar Long = require('long');\n/**\n * Object to easily parse buffer.\n *\n */\n\n\nvar Packet =\n/*#__PURE__*/\nfunction () {\n  function Packet(buf, pos, end) {\n    _classCallCheck(this, Packet);\n\n    this.buf = buf;\n    this.pos = pos;\n    this.end = end;\n  }\n\n  _createClass(Packet, [{\n    key: \"skip\",\n    value: function skip(n) {\n      this.pos += n;\n    }\n  }, {\n    key: \"readGeometry\",\n    value: function readGeometry() {\n      var geoBuf = this.readBufferLengthEncoded();\n\n      if (geoBuf === null || geoBuf.length === 0) {\n        return null;\n      }\n\n      var geoPos = 4;\n      return readGeometryObject(false);\n\n      function parseCoordinates(byteOrder) {\n        geoPos += 16;\n        var x = byteOrder ? geoBuf.readDoubleLE(geoPos - 16) : geoBuf.readDoubleBE(geoPos - 16);\n        var y = byteOrder ? geoBuf.readDoubleLE(geoPos - 8) : geoBuf.readDoubleBE(geoPos - 8);\n        return [x, y];\n      }\n\n      function readGeometryObject(inner) {\n        var byteOrder = geoBuf[geoPos++];\n        var wkbType = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n        geoPos += 4;\n\n        switch (wkbType) {\n          case 1:\n            //wkbPoint\n            var coords = parseCoordinates(byteOrder);\n            if (inner) return coords;\n            return {\n              type: 'Point',\n              coordinates: coords\n            };\n\n          case 2:\n            //wkbLineString\n            var pointNumber = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n            geoPos += 4;\n            var coordinates = [];\n\n            for (var i = 0; i < pointNumber; i++) {\n              coordinates.push(parseCoordinates(byteOrder));\n            }\n\n            if (inner) return coordinates;\n            return {\n              type: 'LineString',\n              coordinates: coordinates\n            };\n\n          case 3:\n            //wkbPolygon\n            var polygonCoordinates = [];\n            var numRings = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n            geoPos += 4;\n\n            for (var ring = 0; ring < numRings; ring++) {\n              var _pointNumber = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n\n              geoPos += 4;\n              var linesCoordinates = [];\n\n              for (var _i = 0; _i < _pointNumber; _i++) {\n                linesCoordinates.push(parseCoordinates(byteOrder));\n              }\n\n              polygonCoordinates.push(linesCoordinates);\n            }\n\n            if (inner) return polygonCoordinates;\n            return {\n              type: 'Polygon',\n              coordinates: polygonCoordinates\n            };\n\n          case 4:\n            //wkbMultiPoint\n            return {\n              type: 'MultiPoint',\n              coordinates: parseGeomArray(byteOrder, true)\n            };\n\n          case 5:\n            //wkbMultiLineString\n            return {\n              type: 'MultiLineString',\n              coordinates: parseGeomArray(byteOrder, true)\n            };\n\n          case 6:\n            //wkbMultiPolygon\n            return {\n              type: 'MultiPolygon',\n              coordinates: parseGeomArray(byteOrder, true)\n            };\n\n          case 7:\n            //wkbGeometryCollection\n            return {\n              type: 'GeometryCollection',\n              geometries: parseGeomArray(byteOrder, false)\n            };\n        }\n\n        return null;\n      }\n\n      function parseGeomArray(byteOrder, inner) {\n        var coordinates = [];\n        var number = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n        geoPos += 4;\n\n        for (var i = 0; i < number; i++) {\n          coordinates.push(readGeometryObject(inner));\n        }\n\n        return coordinates;\n      }\n    }\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      return this.buf[this.pos];\n    }\n  }, {\n    key: \"remaining\",\n    value: function remaining() {\n      return this.end - this.pos > 0;\n    }\n  }, {\n    key: \"readUInt8\",\n    value: function readUInt8() {\n      return this.buf[this.pos++];\n    }\n  }, {\n    key: \"readUInt16\",\n    value: function readUInt16() {\n      return this.buf[this.pos++] + (this.buf[this.pos++] << 8);\n    }\n  }, {\n    key: \"readUInt24\",\n    value: function readUInt24() {\n      return this.buf[this.pos++] + (this.buf[this.pos++] << 8) + (this.buf[this.pos++] << 16);\n    }\n  }, {\n    key: \"readUInt32\",\n    value: function readUInt32() {\n      return this.buf[this.pos++] + (this.buf[this.pos++] << 8) + (this.buf[this.pos++] << 16) + this.buf[this.pos++] * 0x1000000;\n    }\n  }, {\n    key: \"readInt32\",\n    value: function readInt32() {\n      return this.buf[this.pos++] + (this.buf[this.pos++] << 8) + (this.buf[this.pos++] << 16) + (this.buf[this.pos++] << 24);\n    }\n  }, {\n    key: \"readInt32LE\",\n    value: function readInt32LE() {\n      return (this.buf[this.pos++] << 24) + (this.buf[this.pos++] << 16) + (this.buf[this.pos++] << 8) + this.buf[this.pos++];\n    }\n  }, {\n    key: \"readInt64\",\n    value: function readInt64() {\n      var first = this.readInt32();\n      var second = this.readInt32();\n      var long = new Long(first, second, false);\n\n      if (long.isNegative()) {\n        if (long.lessThan(-9007199254740991)) return long;\n      } else if (long.greaterThan(9007199254740991)) return long;\n\n      return long.toNumber();\n    }\n  }, {\n    key: \"readUInt64\",\n    value: function readUInt64() {\n      var first = this.readInt32();\n      var second = this.readInt32();\n      var long = new Long(first, second, true);\n\n      if (long.isNegative()) {\n        if (long.lessThan(-9007199254740991)) return long;\n      } else if (long.greaterThan(9007199254740991)) return long;\n\n      return long.toNumber();\n    }\n  }, {\n    key: \"readUnsignedLength\",\n    value: function readUnsignedLength() {\n      var type = this.buf[this.pos++] & 0xff;\n\n      switch (type) {\n        case 0xfb:\n          return null;\n\n        case 0xfc:\n          return this.readUInt16();\n\n        case 0xfd:\n          return this.readUInt24();\n\n        case 0xfe:\n          return this.readUInt64();\n\n        default:\n          return type;\n      }\n    }\n  }, {\n    key: \"readBuffer\",\n    value: function readBuffer(len) {\n      this.pos += len;\n      return this.buf.slice(this.pos - len, this.pos);\n    }\n  }, {\n    key: \"readBufferRemaining\",\n    value: function readBufferRemaining() {\n      var b = this.buf.slice(this.pos, this.end);\n      this.pos = this.end;\n      return b;\n    }\n  }, {\n    key: \"readBufferLengthEncoded\",\n    value: function readBufferLengthEncoded() {\n      var len = this.readUnsignedLength();\n      if (len === null) return null;\n      this.pos += len;\n      return this.buf.slice(this.pos - len, this.pos);\n    }\n  }, {\n    key: \"readStringNullEnded\",\n    value: function readStringNullEnded() {\n      var initialPosition = this.pos;\n      var cnt = 0;\n\n      while (this.remaining() > 0 && this.buf[this.pos++] !== 0) {\n        cnt++;\n      }\n\n      return this.buf.toString('utf8', initialPosition, initialPosition + cnt);\n    }\n  }, {\n    key: \"readSignedLength\",\n    value: function readSignedLength() {\n      var type = this.buf[this.pos++];\n\n      switch (type) {\n        case 0xfb:\n          return null;\n\n        case 0xfc:\n          return this.readUInt16();\n\n        case 0xfd:\n          return this.readUInt24();\n\n        case 0xfe:\n          return this.readInt64();\n\n        default:\n          return type;\n      }\n    }\n  }, {\n    key: \"readAsciiStringLengthEncoded\",\n    value: function readAsciiStringLengthEncoded() {\n      var len = this.readUnsignedLength();\n      if (len === null) return null;\n      this.pos += len;\n      return this.buf.toString('ascii', this.pos - len, this.pos);\n    }\n  }, {\n    key: \"readStringLengthEncoded\",\n    value: function readStringLengthEncoded(encoding) {\n      var len = this.readUnsignedLength();\n      if (len === null) return null;\n      this.pos += len;\n\n      if (Buffer.isEncoding(encoding)) {\n        return this.buf.toString(encoding, this.pos - len, this.pos);\n      }\n\n      return Iconv.decode(this.buf.slice(this.pos - len, this.pos), encoding);\n    }\n  }, {\n    key: \"readLongLengthEncoded\",\n    value: function readLongLengthEncoded(supportBigNumbers, bigNumberStrings, unsigned) {\n      var len = this.readUnsignedLength();\n      if (len === null) return null;\n      var result = 0;\n      var negate = false;\n      var begin = this.pos; //minus sign\n\n      if (len > 0 && this.buf[begin] === 45) {\n        negate = true;\n        begin++;\n      }\n\n      for (; begin < this.pos + len; begin++) {\n        result = result * 10 + (this.buf[begin] - 48);\n      }\n\n      var val = negate ? -1 * result : result;\n      this.pos += len;\n\n      if (!Number.isSafeInteger(val)) {\n        var str = this.buf.toString('ascii', this.pos - len, this.pos);\n        if (bigNumberStrings) return str;\n\n        if (supportBigNumbers) {\n          return Long.fromString(str, unsigned, 10);\n        }\n      }\n\n      return val;\n    }\n  }, {\n    key: \"readDecimalLengthEncoded\",\n    value: function readDecimalLengthEncoded(supportBigNumbers, bigNumberStrings) {\n      var len = this.readUnsignedLength();\n      if (len === null) return null;\n      this.pos += len;\n      var str = this.buf.toString('ascii', this.pos - len, this.pos);\n      return bigNumberStrings ? str : parseFloat(str);\n    }\n  }, {\n    key: \"readDate\",\n    value: function readDate() {\n      var len = this.readUnsignedLength();\n      if (len === null) return null;\n      var res = [];\n      var value = 0;\n      var initPos = this.pos;\n      this.pos += len;\n\n      while (initPos < this.pos) {\n        var char = this.buf[initPos++];\n\n        if (char === 45) {\n          //minus separator\n          res.push(value);\n          value = 0;\n        } else {\n          value = value * 10 + char - 48;\n        }\n      }\n\n      res.push(value); //handle zero-date as null\n\n      if (res[0] === 0 && res[1] === 0 && res[2] === 0) return null;\n      return new Date(res[0], res[1] - 1, res[2]);\n    }\n  }, {\n    key: \"readDateTime\",\n    value: function readDateTime(opts) {\n      var len = this.readUnsignedLength();\n      if (len === null) return null;\n      this.pos += len;\n      var str = this.buf.toString('ascii', this.pos - len, this.pos);\n      if (str.startsWith('0000-00-00 00:00:00')) return null;\n\n      if (opts.tz) {\n        return new Date(opts.tz(str).clone().tz(opts.localTz).format('YYYY-MM-DD HH:mm:ss.SSSSSS'));\n      }\n\n      return new Date(str);\n    }\n  }, {\n    key: \"readIntLengthEncoded\",\n    value: function readIntLengthEncoded() {\n      var len = this.readUnsignedLength();\n      if (len === null) return null;\n      var result = 0;\n      var negate = false;\n      var begin = this.pos;\n\n      if (len > 0 && this.buf[begin] === 45) {\n        //minus sign\n        negate = true;\n        begin++;\n      }\n\n      for (; begin < this.pos + len; begin++) {\n        result = result * 10 + (this.buf[begin] - 48);\n      }\n\n      this.pos += len;\n      return negate ? -1 * result : result;\n    }\n  }, {\n    key: \"readFloatLengthCoded\",\n    value: function readFloatLengthCoded() {\n      var len = this.readUnsignedLength();\n\n      if (len === 0 || !len) {\n        return len;\n      }\n\n      var result = 0;\n      var end = this.pos + len;\n      var factor = 1;\n      var dotfactor = 1;\n      var resultDot = 0;\n      var charCode = 0; //-\n\n      if (this.buf[this.pos] === 45) {\n        this.pos++;\n        factor = -1;\n      } //+\n\n\n      if (this.buf[this.pos] === 43) {\n        this.pos++; // just ignore\n      }\n\n      while (this.pos < end) {\n        charCode = this.buf[this.pos];\n\n        if (charCode === 46) {\n          //dot\n          this.pos++;\n          dotfactor = 1;\n\n          while (this.pos < end) {\n            dotfactor *= 10;\n            resultDot *= 10;\n            resultDot += this.buf[this.pos++] - 48;\n          }\n        } else {\n          result *= 10;\n          result += this.buf[this.pos++] - 48;\n        }\n      }\n\n      return factor * (result + resultDot / dotfactor);\n    }\n  }, {\n    key: \"skipLengthCodedNumber\",\n    value: function skipLengthCodedNumber() {\n      var type = this.buf[this.pos++] & 0xff;\n\n      switch (type) {\n        case 251:\n          return;\n\n        case 252:\n          this.pos += 2 + (0xffff & (this.buf[this.pos] & 0xff) + ((this.buf[this.pos + 1] & 0xff) << 8));\n          return;\n\n        case 253:\n          this.pos += 3 + (0xffffff & (this.buf[this.pos] & 0xff) + ((this.buf[this.pos + 1] & 0xff) << 8) + ((this.buf[this.pos + 2] & 0xff) << 16));\n          return;\n\n        case 254:\n          this.pos += 8 + ((this.buf[this.pos] & 0xff) + ((this.buf[this.pos + 1] & 0xff) << 8) + ((this.buf[this.pos + 2] & 0xff) << 16) + ((this.buf[this.pos + 3] & 0xff) << 24) + ((this.buf[this.pos + 4] & 0xff) << 32) + ((this.buf[this.pos + 5] & 0xff) << 40) + ((this.buf[this.pos + 6] & 0xff) << 48) + ((this.buf[this.pos + 7] & 0xff) << 56));\n          return;\n\n        default:\n          this.pos += type;\n          return;\n      }\n    }\n  }, {\n    key: \"positionFromEnd\",\n    value: function positionFromEnd(num) {\n      this.pos = this.end - num;\n    }\n    /**\n     * For testing purpose only\n     */\n\n  }, {\n    key: \"_toBuf\",\n    value: function _toBuf() {\n      return this.buf.slice(this.pos, this.end);\n    }\n  }, {\n    key: \"forceOffset\",\n    value: function forceOffset(off) {\n      this.pos = off;\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this.end - this.pos;\n    }\n  }, {\n    key: \"subPacketLengthEncoded\",\n    value: function subPacketLengthEncoded() {\n      var len = this.readUnsignedLength();\n      this.skip(len);\n      return new Packet(this.buf, this.pos - len, this.pos);\n    }\n    /**\n     * Parse ERR_Packet : https://mariadb.com/kb/en/library/err_packet/\n     *\n     * @param info              current connection info\n     * @param sql               command sql\n     * @param stack             additional stack trace\n     * @returns {Error}\n     */\n\n  }, {\n    key: \"readError\",\n    value: function readError(info, sql, stack) {\n      this.skip(1);\n      var errorCode = this.readUInt16();\n      var sqlState = '';\n\n      if (this.peek() === 0x23) {\n        this.skip(6);\n        sqlState = this.buf.toString('utf8', this.pos - 5, this.pos);\n      }\n\n      var msg = this.buf.toString('utf8', this.pos, this.end);\n      if (sql) msg += '\\n' + sql;\n      var fatal = sqlState.startsWith('08') || sqlState === '70100';\n\n      if (fatal) {\n        var packetMsgs = info.getLastPackets();\n        if (packetMsgs !== '') return Errors.createError(msg + '\\nlast received packets:\\n' + packetMsgs, fatal, info, sqlState, errorCode, stack);\n      }\n\n      return Errors.createError(msg, fatal, info, sqlState, errorCode, stack);\n    }\n  }]);\n\n  return Packet;\n}();\n\nmodule.exports = Packet;","map":{"version":3,"sources":["C:/Users/dembr/Documents/GitHub/react_projects/react-urol-database/node_modules/mariadb/lib/io/packet.js"],"names":["Errors","require","Iconv","Long","Packet","buf","pos","end","n","geoBuf","readBufferLengthEncoded","length","geoPos","readGeometryObject","parseCoordinates","byteOrder","x","readDoubleLE","readDoubleBE","y","inner","wkbType","readInt32LE","readInt32BE","coords","type","coordinates","pointNumber","i","push","polygonCoordinates","numRings","ring","linesCoordinates","parseGeomArray","geometries","number","first","readInt32","second","long","isNegative","lessThan","greaterThan","toNumber","readUInt16","readUInt24","readUInt64","len","slice","b","readUnsignedLength","initialPosition","cnt","remaining","toString","readInt64","encoding","Buffer","isEncoding","decode","supportBigNumbers","bigNumberStrings","unsigned","result","negate","begin","val","Number","isSafeInteger","str","fromString","parseFloat","res","value","initPos","char","Date","opts","startsWith","tz","clone","localTz","format","factor","dotfactor","resultDot","charCode","num","off","skip","info","sql","stack","errorCode","sqlState","peek","msg","fatal","packetMsgs","getLastPackets","createError","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Errors = require('../misc/errors');\nconst Iconv = require('iconv-lite');\nconst Long = require('long');\n\n/**\n * Object to easily parse buffer.\n *\n */\nclass Packet {\n  constructor(buf, pos, end) {\n    this.buf = buf;\n    this.pos = pos;\n    this.end = end;\n  }\n\n  skip(n) {\n    this.pos += n;\n  }\n  readGeometry() {\n    const geoBuf = this.readBufferLengthEncoded();\n    if (geoBuf === null || geoBuf.length === 0) {\n      return null;\n    }\n    let geoPos = 4;\n    return readGeometryObject(false);\n\n    function parseCoordinates(byteOrder) {\n      geoPos += 16;\n      const x = byteOrder ? geoBuf.readDoubleLE(geoPos - 16) : geoBuf.readDoubleBE(geoPos - 16);\n      const y = byteOrder ? geoBuf.readDoubleLE(geoPos - 8) : geoBuf.readDoubleBE(geoPos - 8);\n      return [x, y];\n    }\n\n    function readGeometryObject(inner) {\n      const byteOrder = geoBuf[geoPos++];\n      const wkbType = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n      geoPos += 4;\n      switch (wkbType) {\n        case 1: //wkbPoint\n          const coords = parseCoordinates(byteOrder);\n\n          if (inner) return coords;\n          return {\n            type: 'Point',\n            coordinates: coords\n          };\n\n        case 2: //wkbLineString\n          const pointNumber = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n          geoPos += 4;\n          let coordinates = [];\n          for (let i = 0; i < pointNumber; i++) {\n            coordinates.push(parseCoordinates(byteOrder));\n          }\n          if (inner) return coordinates;\n          return {\n            type: 'LineString',\n            coordinates: coordinates\n          };\n\n        case 3: //wkbPolygon\n          let polygonCoordinates = [];\n          const numRings = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n          geoPos += 4;\n          for (let ring = 0; ring < numRings; ring++) {\n            const pointNumber = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n            geoPos += 4;\n            let linesCoordinates = [];\n            for (let i = 0; i < pointNumber; i++) {\n              linesCoordinates.push(parseCoordinates(byteOrder));\n            }\n            polygonCoordinates.push(linesCoordinates);\n          }\n\n          if (inner) return polygonCoordinates;\n          return {\n            type: 'Polygon',\n            coordinates: polygonCoordinates\n          };\n\n        case 4: //wkbMultiPoint\n          return {\n            type: 'MultiPoint',\n            coordinates: parseGeomArray(byteOrder, true)\n          };\n\n        case 5: //wkbMultiLineString\n          return {\n            type: 'MultiLineString',\n            coordinates: parseGeomArray(byteOrder, true)\n          };\n        case 6: //wkbMultiPolygon\n          return {\n            type: 'MultiPolygon',\n            coordinates: parseGeomArray(byteOrder, true)\n          };\n        case 7: //wkbGeometryCollection\n          return {\n            type: 'GeometryCollection',\n            geometries: parseGeomArray(byteOrder, false)\n          };\n      }\n      return null;\n    }\n\n    function parseGeomArray(byteOrder, inner) {\n      let coordinates = [];\n      const number = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n      geoPos += 4;\n      for (let i = 0; i < number; i++) {\n        coordinates.push(readGeometryObject(inner));\n      }\n      return coordinates;\n    }\n  }\n\n  peek() {\n    return this.buf[this.pos];\n  }\n\n  remaining() {\n    return this.end - this.pos > 0;\n  }\n\n  readUInt8() {\n    return this.buf[this.pos++];\n  }\n\n  readUInt16() {\n    return this.buf[this.pos++] + (this.buf[this.pos++] << 8);\n  }\n\n  readUInt24() {\n    return this.buf[this.pos++] + (this.buf[this.pos++] << 8) + (this.buf[this.pos++] << 16);\n  }\n\n  readUInt32() {\n    return (\n      this.buf[this.pos++] +\n      (this.buf[this.pos++] << 8) +\n      (this.buf[this.pos++] << 16) +\n      this.buf[this.pos++] * 0x1000000\n    );\n  }\n\n  readInt32() {\n    return (\n      this.buf[this.pos++] +\n      (this.buf[this.pos++] << 8) +\n      (this.buf[this.pos++] << 16) +\n      (this.buf[this.pos++] << 24)\n    );\n  }\n\n  readInt32LE() {\n    return (\n      (this.buf[this.pos++] << 24) +\n      (this.buf[this.pos++] << 16) +\n      (this.buf[this.pos++] << 8) +\n      this.buf[this.pos++]\n    );\n  }\n\n  readInt64() {\n    const first = this.readInt32();\n    const second = this.readInt32();\n\n    const long = new Long(first, second, false);\n    if (long.isNegative()) {\n      if (long.lessThan(-9007199254740991)) return long;\n    } else if (long.greaterThan(9007199254740991)) return long;\n\n    return long.toNumber();\n  }\n\n  readUInt64() {\n    const first = this.readInt32();\n    const second = this.readInt32();\n\n    const long = new Long(first, second, true);\n    if (long.isNegative()) {\n      if (long.lessThan(-9007199254740991)) return long;\n    } else if (long.greaterThan(9007199254740991)) return long;\n\n    return long.toNumber();\n  }\n\n  readUnsignedLength() {\n    const type = this.buf[this.pos++] & 0xff;\n    switch (type) {\n      case 0xfb:\n        return null;\n      case 0xfc:\n        return this.readUInt16();\n      case 0xfd:\n        return this.readUInt24();\n      case 0xfe:\n        return this.readUInt64();\n      default:\n        return type;\n    }\n  }\n\n  readBuffer(len) {\n    this.pos += len;\n    return this.buf.slice(this.pos - len, this.pos);\n  }\n\n  readBufferRemaining() {\n    let b = this.buf.slice(this.pos, this.end);\n    this.pos = this.end;\n    return b;\n  }\n\n  readBufferLengthEncoded() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    this.pos += len;\n    return this.buf.slice(this.pos - len, this.pos);\n  }\n\n  readStringNullEnded() {\n    let initialPosition = this.pos;\n    let cnt = 0;\n    while (this.remaining() > 0 && this.buf[this.pos++] !== 0) {\n      cnt++;\n    }\n    return this.buf.toString('utf8', initialPosition, initialPosition + cnt);\n  }\n\n  readSignedLength() {\n    const type = this.buf[this.pos++];\n    switch (type) {\n      case 0xfb:\n        return null;\n      case 0xfc:\n        return this.readUInt16();\n      case 0xfd:\n        return this.readUInt24();\n      case 0xfe:\n        return this.readInt64();\n      default:\n        return type;\n    }\n  }\n\n  readAsciiStringLengthEncoded() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    this.pos += len;\n    return this.buf.toString('ascii', this.pos - len, this.pos);\n  }\n\n  readStringLengthEncoded(encoding) {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n\n    this.pos += len;\n    if (Buffer.isEncoding(encoding)) {\n      return this.buf.toString(encoding, this.pos - len, this.pos);\n    }\n    return Iconv.decode(this.buf.slice(this.pos - len, this.pos), encoding);\n  }\n\n  readLongLengthEncoded(supportBigNumbers, bigNumberStrings, unsigned) {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n\n    let result = 0;\n    let negate = false;\n    let begin = this.pos;\n\n    //minus sign\n    if (len > 0 && this.buf[begin] === 45) {\n      negate = true;\n      begin++;\n    }\n    for (; begin < this.pos + len; begin++) {\n      result = result * 10 + (this.buf[begin] - 48);\n    }\n\n    let val = negate ? -1 * result : result;\n    this.pos += len;\n\n    if (!Number.isSafeInteger(val)) {\n      const str = this.buf.toString('ascii', this.pos - len, this.pos);\n      if (bigNumberStrings) return str;\n      if (supportBigNumbers) {\n        return Long.fromString(str, unsigned, 10);\n      }\n    }\n    return val;\n  }\n\n  readDecimalLengthEncoded(supportBigNumbers, bigNumberStrings) {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n\n    this.pos += len;\n    let str = this.buf.toString('ascii', this.pos - len, this.pos);\n    return bigNumberStrings ? str : parseFloat(str);\n  }\n\n  readDate() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n\n    let res = [];\n    let value = 0;\n    let initPos = this.pos;\n    this.pos += len;\n    while (initPos < this.pos) {\n      const char = this.buf[initPos++];\n      if (char === 45) {\n        //minus separator\n        res.push(value);\n        value = 0;\n      } else {\n        value = value * 10 + char - 48;\n      }\n    }\n    res.push(value);\n\n    //handle zero-date as null\n    if (res[0] === 0 && res[1] === 0 && res[2] === 0) return null;\n\n    return new Date(res[0], res[1] - 1, res[2]);\n  }\n\n  readDateTime(opts) {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    this.pos += len;\n    const str = this.buf.toString('ascii', this.pos - len, this.pos);\n    if (str.startsWith('0000-00-00 00:00:00')) return null;\n\n    if (opts.tz) {\n      return new Date(\n        opts\n          .tz(str)\n          .clone()\n          .tz(opts.localTz)\n          .format('YYYY-MM-DD HH:mm:ss.SSSSSS')\n      );\n    }\n    return new Date(str);\n  }\n\n  readIntLengthEncoded() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n\n    let result = 0;\n    let negate = false;\n    let begin = this.pos;\n\n    if (len > 0 && this.buf[begin] === 45) {\n      //minus sign\n      negate = true;\n      begin++;\n    }\n    for (; begin < this.pos + len; begin++) {\n      result = result * 10 + (this.buf[begin] - 48);\n    }\n    this.pos += len;\n    return negate ? -1 * result : result;\n  }\n\n  readFloatLengthCoded() {\n    const len = this.readUnsignedLength();\n\n    if (len === 0 || !len) {\n      return len;\n    }\n\n    let result = 0;\n    let end = this.pos + len;\n    let factor = 1;\n    let dotfactor = 1;\n    let resultDot = 0;\n    let charCode = 0;\n\n    //-\n    if (this.buf[this.pos] === 45) {\n      this.pos++;\n      factor = -1;\n    }\n\n    //+\n    if (this.buf[this.pos] === 43) {\n      this.pos++; // just ignore\n    }\n\n    while (this.pos < end) {\n      charCode = this.buf[this.pos];\n      if (charCode === 46) {\n        //dot\n        this.pos++;\n\n        dotfactor = 1;\n        while (this.pos < end) {\n          dotfactor *= 10;\n          resultDot *= 10;\n          resultDot += this.buf[this.pos++] - 48;\n        }\n      } else {\n        result *= 10;\n        result += this.buf[this.pos++] - 48;\n      }\n    }\n\n    return factor * (result + resultDot / dotfactor);\n  }\n\n  skipLengthCodedNumber() {\n    const type = this.buf[this.pos++] & 0xff;\n    switch (type) {\n      case 251:\n        return;\n      case 252:\n        this.pos +=\n          2 + (0xffff & ((this.buf[this.pos] & 0xff) + ((this.buf[this.pos + 1] & 0xff) << 8)));\n        return;\n      case 253:\n        this.pos +=\n          3 +\n          (0xffffff &\n            ((this.buf[this.pos] & 0xff) +\n              ((this.buf[this.pos + 1] & 0xff) << 8) +\n              ((this.buf[this.pos + 2] & 0xff) << 16)));\n        return;\n      case 254:\n        this.pos +=\n          8 +\n          ((this.buf[this.pos] & 0xff) +\n            ((this.buf[this.pos + 1] & 0xff) << 8) +\n            ((this.buf[this.pos + 2] & 0xff) << 16) +\n            ((this.buf[this.pos + 3] & 0xff) << 24) +\n            ((this.buf[this.pos + 4] & 0xff) << 32) +\n            ((this.buf[this.pos + 5] & 0xff) << 40) +\n            ((this.buf[this.pos + 6] & 0xff) << 48) +\n            ((this.buf[this.pos + 7] & 0xff) << 56));\n        return;\n      default:\n        this.pos += type;\n        return;\n    }\n  }\n\n  positionFromEnd(num) {\n    this.pos = this.end - num;\n  }\n\n  /**\n   * For testing purpose only\n   */\n  _toBuf() {\n    return this.buf.slice(this.pos, this.end);\n  }\n\n  forceOffset(off) {\n    this.pos = off;\n  }\n\n  length() {\n    return this.end - this.pos;\n  }\n\n  subPacketLengthEncoded() {\n    const len = this.readUnsignedLength();\n    this.skip(len);\n    return new Packet(this.buf, this.pos - len, this.pos);\n  }\n\n  /**\n   * Parse ERR_Packet : https://mariadb.com/kb/en/library/err_packet/\n   *\n   * @param info              current connection info\n   * @param sql               command sql\n   * @param stack             additional stack trace\n   * @returns {Error}\n   */\n  readError(info, sql, stack) {\n    this.skip(1);\n    let errorCode = this.readUInt16();\n    let sqlState = '';\n\n    if (this.peek() === 0x23) {\n      this.skip(6);\n      sqlState = this.buf.toString('utf8', this.pos - 5, this.pos);\n    }\n\n    let msg = this.buf.toString('utf8', this.pos, this.end);\n    if (sql) msg += '\\n' + sql;\n    let fatal = sqlState.startsWith('08') || sqlState === '70100';\n    if (fatal) {\n      const packetMsgs = info.getLastPackets();\n      if (packetMsgs !== '')\n        return Errors.createError(\n          msg + '\\nlast received packets:\\n' + packetMsgs,\n          fatal,\n          info,\n          sqlState,\n          errorCode,\n          stack\n        );\n    }\n    return Errors.createError(msg, fatal, info, sqlState, errorCode, stack);\n  }\n}\n\nmodule.exports = Packet;\n"]},"metadata":{},"sourceType":"script"}