{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\dembr\\\\Documents\\\\GitHub\\\\react_projects\\\\react-urol-database\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\dembr\\\\Documents\\\\GitHub\\\\react_projects\\\\react-urol-database\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar Utils = require('../misc/utils');\n\nvar ZLib = require('zlib'); //increase by level to avoid buffer copy.\n\n\nvar SMALL_BUFFER_SIZE = 2048;\nvar MEDIUM_BUFFER_SIZE = 131072; //128k\n\nvar LARGE_BUFFER_SIZE = 1048576; //1M\n\nvar MAX_BUFFER_SIZE = 16777222; //16M + 7\n\n/**\n/**\n * MySQL compression filter.\n * see https://mariadb.com/kb/en/library/0-packet/#compressed-packet\n */\n\nvar CompressionOutputStream =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Constructor\n   *\n   * @param socket    current socket\n   * @param opts      current connection options\n   * @param info      current connection information\n   * @constructor\n   */\n  function CompressionOutputStream(socket, opts, info) {\n    _classCallCheck(this, CompressionOutputStream);\n\n    this.info = info;\n    this.opts = opts;\n    this.pos = 7;\n    this.header = Buffer.allocUnsafe(7);\n    this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n\n    this.writer = function (buffer) {\n      socket.write(buffer);\n    };\n  }\n\n  _createClass(CompressionOutputStream, [{\n    key: \"growBuffer\",\n    value: function growBuffer(len) {\n      var newCapacity;\n\n      if (len + this.pos < MEDIUM_BUFFER_SIZE) {\n        newCapacity = MEDIUM_BUFFER_SIZE;\n      } else if (len + this.pos < LARGE_BUFFER_SIZE) {\n        newCapacity = LARGE_BUFFER_SIZE;\n      } else newCapacity = MAX_BUFFER_SIZE;\n\n      var newBuf = Buffer.allocUnsafe(newCapacity);\n      this.buf.copy(newBuf, 0, 0, this.pos);\n      this.buf = newBuf;\n    }\n  }, {\n    key: \"writeBuf\",\n    value: function writeBuf(arr, cmd) {\n      var off = 0,\n          len = arr.length;\n\n      if (len > this.buf.length - this.pos) {\n        if (this.buf.length !== MAX_BUFFER_SIZE) {\n          this.growBuffer(len);\n        } //max buffer size\n\n\n        if (len > this.buf.length - this.pos) {\n          //not enough space in buffer, will stream :\n          // fill buffer and flush until all data are snd\n          var remainingLen = len;\n\n          while (true) {\n            //filling buffer\n            var lenToFillBuffer = Math.min(MAX_BUFFER_SIZE - this.pos, remainingLen);\n            arr.copy(this.buf, this.pos, off, off + lenToFillBuffer);\n            remainingLen -= lenToFillBuffer;\n            off += lenToFillBuffer;\n            this.pos += lenToFillBuffer;\n            if (remainingLen === 0) return;\n            this.flush(false, cmd, remainingLen);\n          }\n        }\n      }\n\n      arr.copy(this.buf, this.pos, off, off + len);\n      this.pos += len;\n    }\n    /**\n     * Flush the internal buffer.\n     */\n\n  }, {\n    key: \"flush\",\n    value: function flush(cmdEnd, cmd, remainingLen) {\n      if (this.pos < 1536) {\n        //*******************************************************************************\n        // small packet, no compression\n        //*******************************************************************************\n        this.buf[0] = this.pos - 7;\n        this.buf[1] = this.pos - 7 >>> 8;\n        this.buf[2] = this.pos - 7 >>> 16;\n        this.buf[3] = ++cmd.compressSequenceNo;\n        this.buf[4] = 0;\n        this.buf[5] = 0;\n        this.buf[6] = 0;\n\n        if (this.opts.debugCompress) {\n          console.log('==> conn:%d %s (compress)\\n%s', this.info.threadId ? this.info.threadId : -1, cmd ? cmd.constructor.name + '(0,' + this.pos + ')' : 'unknown', Utils.log(this.opts, this.buf, 0, this.pos));\n        }\n\n        this.writer(this.buf.slice(0, this.pos));\n      } else {\n        //*******************************************************************************\n        // compressing packet\n        //*******************************************************************************\n        //use synchronous inflating, to ensure FIFO packet order\n        var compressChunk = ZLib.deflateSync(this.buf.slice(7, this.pos));\n        var compressChunkLen = compressChunk.length;\n        this.header[0] = compressChunkLen;\n        this.header[1] = compressChunkLen >>> 8;\n        this.header[2] = compressChunkLen >>> 16;\n        this.header[3] = ++cmd.compressSequenceNo;\n        this.header[4] = this.pos - 7;\n        this.header[5] = this.pos - 7 >>> 8;\n        this.header[6] = this.pos - 7 >>> 16;\n\n        if (this.opts.debugCompress) {\n          console.log('==> conn:%d %s (compress)\\n%s', this.info.threadId ? this.info.threadId : -1, cmd ? cmd.constructor.name + '(0,' + this.pos + '=>' + compressChunkLen + ')' : 'unknown', Utils.log(this.opts, compressChunk, 0, compressChunkLen, this.header));\n        }\n\n        this.writer(this.header);\n        this.writer(compressChunk);\n        if (cmdEnd && this.pos === MAX_BUFFER_SIZE) this.writeEmptyPacket(cmd);\n        this.header = Buffer.allocUnsafe(7);\n      }\n\n      this.buf = remainingLen ? CompressionOutputStream.allocateBuffer(remainingLen) : Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n      this.pos = 7;\n    }\n  }, {\n    key: \"writeEmptyPacket\",\n    value: function writeEmptyPacket(cmd) {\n      var emptyBuf = Buffer.from([0x00, 0x00, 0x00, cmd.compressSequenceNo, 0x00, 0x00, 0x00]);\n\n      if (this.opts.debugCompress) {\n        console.log('==> conn:%d %s (compress)\\n%s', this.info.threadId ? this.info.threadId : -1, cmd ? cmd.constructor.name + '(0,' + this.pos + ')' : 'unknown', Utils.log(this.opts, emptyBuf, 0, 7));\n      }\n\n      this.writer(emptyBuf);\n    }\n  }], [{\n    key: \"allocateBuffer\",\n    value: function allocateBuffer(len) {\n      if (len + 4 < SMALL_BUFFER_SIZE) {\n        return Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n      } else if (len + 4 < MEDIUM_BUFFER_SIZE) {\n        return Buffer.allocUnsafe(MEDIUM_BUFFER_SIZE);\n      } else if (len + 4 < LARGE_BUFFER_SIZE) {\n        return Buffer.allocUnsafe(LARGE_BUFFER_SIZE);\n      }\n\n      return Buffer.allocUnsafe(MAX_BUFFER_SIZE);\n    }\n  }]);\n\n  return CompressionOutputStream;\n}();\n\nmodule.exports = CompressionOutputStream;","map":{"version":3,"sources":["C:/Users/dembr/Documents/GitHub/react_projects/react-urol-database/node_modules/mariadb/lib/io/compression-output-stream.js"],"names":["Utils","require","ZLib","SMALL_BUFFER_SIZE","MEDIUM_BUFFER_SIZE","LARGE_BUFFER_SIZE","MAX_BUFFER_SIZE","CompressionOutputStream","socket","opts","info","pos","header","Buffer","allocUnsafe","buf","writer","buffer","write","len","newCapacity","newBuf","copy","arr","cmd","off","length","growBuffer","remainingLen","lenToFillBuffer","Math","min","flush","cmdEnd","compressSequenceNo","debugCompress","console","log","threadId","constructor","name","slice","compressChunk","deflateSync","compressChunkLen","writeEmptyPacket","allocateBuffer","emptyBuf","from","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Utils = require('../misc/utils');\nconst ZLib = require('zlib');\n\n//increase by level to avoid buffer copy.\nconst SMALL_BUFFER_SIZE = 2048;\nconst MEDIUM_BUFFER_SIZE = 131072; //128k\nconst LARGE_BUFFER_SIZE = 1048576; //1M\nconst MAX_BUFFER_SIZE = 16777222; //16M + 7\n\n/**\n/**\n * MySQL compression filter.\n * see https://mariadb.com/kb/en/library/0-packet/#compressed-packet\n */\nclass CompressionOutputStream {\n  /**\n   * Constructor\n   *\n   * @param socket    current socket\n   * @param opts      current connection options\n   * @param info      current connection information\n   * @constructor\n   */\n  constructor(socket, opts, info) {\n    this.info = info;\n    this.opts = opts;\n    this.pos = 7;\n    this.header = Buffer.allocUnsafe(7);\n    this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n    this.writer = buffer => {\n      socket.write(buffer);\n    };\n  }\n\n  growBuffer(len) {\n    let newCapacity;\n    if (len + this.pos < MEDIUM_BUFFER_SIZE) {\n      newCapacity = MEDIUM_BUFFER_SIZE;\n    } else if (len + this.pos < LARGE_BUFFER_SIZE) {\n      newCapacity = LARGE_BUFFER_SIZE;\n    } else newCapacity = MAX_BUFFER_SIZE;\n\n    let newBuf = Buffer.allocUnsafe(newCapacity);\n    this.buf.copy(newBuf, 0, 0, this.pos);\n    this.buf = newBuf;\n  }\n\n  writeBuf(arr, cmd) {\n    let off = 0,\n      len = arr.length;\n    if (len > this.buf.length - this.pos) {\n      if (this.buf.length !== MAX_BUFFER_SIZE) {\n        this.growBuffer(len);\n      }\n\n      //max buffer size\n      if (len > this.buf.length - this.pos) {\n        //not enough space in buffer, will stream :\n        // fill buffer and flush until all data are snd\n        let remainingLen = len;\n\n        while (true) {\n          //filling buffer\n          let lenToFillBuffer = Math.min(MAX_BUFFER_SIZE - this.pos, remainingLen);\n          arr.copy(this.buf, this.pos, off, off + lenToFillBuffer);\n          remainingLen -= lenToFillBuffer;\n          off += lenToFillBuffer;\n          this.pos += lenToFillBuffer;\n\n          if (remainingLen === 0) return;\n          this.flush(false, cmd, remainingLen);\n        }\n      }\n    }\n    arr.copy(this.buf, this.pos, off, off + len);\n    this.pos += len;\n  }\n\n  /**\n   * Flush the internal buffer.\n   */\n  flush(cmdEnd, cmd, remainingLen) {\n    if (this.pos < 1536) {\n      //*******************************************************************************\n      // small packet, no compression\n      //*******************************************************************************\n\n      this.buf[0] = this.pos - 7;\n      this.buf[1] = (this.pos - 7) >>> 8;\n      this.buf[2] = (this.pos - 7) >>> 16;\n      this.buf[3] = ++cmd.compressSequenceNo;\n      this.buf[4] = 0;\n      this.buf[5] = 0;\n      this.buf[6] = 0;\n\n      if (this.opts.debugCompress) {\n        console.log(\n          '==> conn:%d %s (compress)\\n%s',\n          this.info.threadId ? this.info.threadId : -1,\n          cmd ? cmd.constructor.name + '(0,' + this.pos + ')' : 'unknown',\n          Utils.log(this.opts, this.buf, 0, this.pos)\n        );\n      }\n\n      this.writer(this.buf.slice(0, this.pos));\n    } else {\n      //*******************************************************************************\n      // compressing packet\n      //*******************************************************************************\n      //use synchronous inflating, to ensure FIFO packet order\n      const compressChunk = ZLib.deflateSync(this.buf.slice(7, this.pos));\n      const compressChunkLen = compressChunk.length;\n\n      this.header[0] = compressChunkLen;\n      this.header[1] = compressChunkLen >>> 8;\n      this.header[2] = compressChunkLen >>> 16;\n      this.header[3] = ++cmd.compressSequenceNo;\n      this.header[4] = this.pos - 7;\n      this.header[5] = (this.pos - 7) >>> 8;\n      this.header[6] = (this.pos - 7) >>> 16;\n\n      if (this.opts.debugCompress) {\n        console.log(\n          '==> conn:%d %s (compress)\\n%s',\n          this.info.threadId ? this.info.threadId : -1,\n          cmd ? cmd.constructor.name + '(0,' + this.pos + '=>' + compressChunkLen + ')' : 'unknown',\n          Utils.log(this.opts, compressChunk, 0, compressChunkLen, this.header)\n        );\n      }\n\n      this.writer(this.header);\n      this.writer(compressChunk);\n      if (cmdEnd && this.pos === MAX_BUFFER_SIZE) this.writeEmptyPacket(cmd);\n      this.header = Buffer.allocUnsafe(7);\n    }\n    this.buf = remainingLen\n      ? CompressionOutputStream.allocateBuffer(remainingLen)\n      : Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n    this.pos = 7;\n  }\n\n  static allocateBuffer(len) {\n    if (len + 4 < SMALL_BUFFER_SIZE) {\n      return Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n    } else if (len + 4 < MEDIUM_BUFFER_SIZE) {\n      return Buffer.allocUnsafe(MEDIUM_BUFFER_SIZE);\n    } else if (len + 4 < LARGE_BUFFER_SIZE) {\n      return Buffer.allocUnsafe(LARGE_BUFFER_SIZE);\n    }\n    return Buffer.allocUnsafe(MAX_BUFFER_SIZE);\n  }\n\n  writeEmptyPacket(cmd) {\n    const emptyBuf = Buffer.from([0x00, 0x00, 0x00, cmd.compressSequenceNo, 0x00, 0x00, 0x00]);\n\n    if (this.opts.debugCompress) {\n      console.log(\n        '==> conn:%d %s (compress)\\n%s',\n        this.info.threadId ? this.info.threadId : -1,\n        cmd ? cmd.constructor.name + '(0,' + this.pos + ')' : 'unknown',\n        Utils.log(this.opts, emptyBuf, 0, 7)\n      );\n    }\n\n    this.writer(emptyBuf);\n  }\n}\n\nmodule.exports = CompressionOutputStream;\n"]},"metadata":{},"sourceType":"script"}