{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\dembr\\\\Documents\\\\GitHub\\\\react_projects\\\\react-urol-database\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\dembr\\\\Documents\\\\GitHub\\\\react_projects\\\\react-urol-database\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\dembr\\\\Documents\\\\GitHub\\\\react_projects\\\\react-urol-database\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\dembr\\\\Documents\\\\GitHub\\\\react_projects\\\\react-urol-database\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\dembr\\\\Documents\\\\GitHub\\\\react_projects\\\\react-urol-database\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar ResultSet = require('./resultset');\n\nvar CommonBinary =\n/*#__PURE__*/\nfunction (_ResultSet) {\n  _inherits(CommonBinary, _ResultSet);\n\n  function CommonBinary(resolve, reject, cmdOpts, connOpts, sql, values) {\n    var _this;\n\n    _classCallCheck(this, CommonBinary);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CommonBinary).call(this, resolve, reject));\n\n    _this.configAssign(connOpts, cmdOpts);\n\n    _this.sql = sql;\n    _this.initialValues = values;\n    return _this;\n  }\n  /**\n   * Write (and escape) current parameter value to output writer\n   *\n   * @param out     output writer\n   * @param value   current parameter\n   * @param opts    connection options\n   * @param info    connection information\n   */\n\n\n  _createClass(CommonBinary, [{\n    key: \"writeParam\",\n    value: function writeParam(out, value, opts, info) {\n      var flushed = false;\n\n      switch (typeof value) {\n        case 'boolean':\n          flushed = out.writeInt8(0x00);\n          flushed = out.writeInt8(value ? 0x01 : 0x00) || flushed;\n          break;\n\n        case 'number':\n          flushed = out.writeInt8(0x00);\n          flushed = out.writeLengthStringAscii('' + value) || flushed;\n          break;\n\n        case 'object':\n          if (Object.prototype.toString.call(value) === '[object Date]') {\n            flushed = out.writeInt8(0x00);\n            flushed = out.writeBinaryDate(value, opts) || flushed;\n          } else if (Buffer.isBuffer(value)) {\n            flushed = out.writeInt8(0x00);\n            flushed = out.writeLengthEncodedBuffer(value) || flushed;\n          } else if (typeof value.toSqlString === 'function') {\n            flushed = out.writeInt8(0x00);\n            flushed = out.writeLengthEncodedString(String(value.toSqlString())) || flushed;\n          } else {\n            if (value.type != null && ['Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon', 'GeometryCollection'].includes(value.type)) {\n              var geoBuff = this.getBufferFromGeometryValue(value);\n\n              if (geoBuff) {\n                flushed = out.writeInt8(0x00); //Value follow\n\n                flushed = out.writeLengthEncodedBuffer(Buffer.concat([Buffer.from([0, 0, 0, 0]), geoBuff])) || flushed;\n              } else {\n                flushed = out.writeInt8(0x01); //NULL\n              }\n            } else {\n              //TODO check if permitSetMultiParamEntries is needed !?\n              flushed = out.writeInt8(0x00);\n              flushed = out.writeLengthEncodedString(JSON.stringify(value)) || flushed;\n            }\n          }\n\n          break;\n\n        default:\n          flushed = out.writeInt8(0x00);\n          flushed = out.writeLengthEncodedString(value) || flushed;\n      }\n\n      return flushed;\n    }\n  }, {\n    key: \"getBufferFromGeometryValue\",\n    value: function getBufferFromGeometryValue(value, headerType) {\n      var geoBuff;\n      var pos;\n      var type;\n\n      if (!headerType) {\n        switch (value.type) {\n          case 'Point':\n            geoBuff = Buffer.allocUnsafe(21);\n            geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n\n            geoBuff.writeInt32LE(1, 1); //wkbPoint\n\n            if (value.coordinates && Array.isArray(value.coordinates) && value.coordinates.length >= 2 && !isNaN(value.coordinates[0]) && !isNaN(value.coordinates[1])) {\n              geoBuff.writeDoubleLE(value.coordinates[0], 5); //X\n\n              geoBuff.writeDoubleLE(value.coordinates[1], 13); //Y\n\n              return geoBuff;\n            } else {\n              return null;\n            }\n\n          case 'LineString':\n            if (value.coordinates && Array.isArray(value.coordinates)) {\n              var pointNumber = value.coordinates.length;\n              geoBuff = Buffer.allocUnsafe(9 + 16 * pointNumber);\n              geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n\n              geoBuff.writeInt32LE(2, 1); //wkbLineString\n\n              geoBuff.writeInt32LE(pointNumber, 5);\n\n              for (var i = 0; i < pointNumber; i++) {\n                if (value.coordinates[i] && Array.isArray(value.coordinates[i]) && value.coordinates[i].length >= 2 && !isNaN(value.coordinates[i][0]) && !isNaN(value.coordinates[i][1])) {\n                  geoBuff.writeDoubleLE(value.coordinates[i][0], 9 + 16 * i); //X\n\n                  geoBuff.writeDoubleLE(value.coordinates[i][1], 17 + 16 * i); //Y\n                } else {\n                  return null;\n                }\n              }\n\n              return geoBuff;\n            } else {\n              return null;\n            }\n\n          case 'Polygon':\n            if (value.coordinates && Array.isArray(value.coordinates)) {\n              var numRings = value.coordinates.length;\n              var size = 0;\n\n              for (var _i = 0; _i < numRings; _i++) {\n                size += 4 + 16 * value.coordinates[_i].length;\n              }\n\n              geoBuff = Buffer.allocUnsafe(9 + size);\n              geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n\n              geoBuff.writeInt32LE(3, 1); //wkbPolygon\n\n              geoBuff.writeInt32LE(numRings, 5);\n              pos = 9;\n\n              for (var _i2 = 0; _i2 < numRings; _i2++) {\n                var lineString = value.coordinates[_i2];\n\n                if (lineString && Array.isArray(lineString)) {\n                  geoBuff.writeInt32LE(lineString.length, pos);\n                  pos += 4;\n\n                  for (var j = 0; j < lineString.length; j++) {\n                    if (lineString[j] && Array.isArray(lineString[j]) && lineString[j].length >= 2 && !isNaN(lineString[j][0]) && !isNaN(lineString[j][1])) {\n                      geoBuff.writeDoubleLE(lineString[j][0], pos); //X\n\n                      geoBuff.writeDoubleLE(lineString[j][1], pos + 8); //Y\n\n                      pos += 16;\n                    } else {\n                      return null;\n                    }\n                  }\n                }\n              }\n\n              return geoBuff;\n            } else {\n              return null;\n            }\n\n          case 'MultiPoint':\n            type = 'MultiPoint';\n            geoBuff = Buffer.allocUnsafe(9);\n            geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n\n            geoBuff.writeInt32LE(4, 1); //wkbMultiPoint\n\n            break;\n\n          case 'MultiLineString':\n            type = 'MultiLineString';\n            geoBuff = Buffer.allocUnsafe(9);\n            geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n\n            geoBuff.writeInt32LE(5, 1); //wkbMultiLineString\n\n            break;\n\n          case 'MultiPolygon':\n            type = 'MultiPolygon';\n            geoBuff = Buffer.allocUnsafe(9);\n            geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n\n            geoBuff.writeInt32LE(6, 1); //wkbMultiPolygon\n\n            break;\n\n          case 'GeometryCollection':\n            geoBuff = Buffer.allocUnsafe(9);\n            geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n\n            geoBuff.writeInt32LE(7, 1); //wkbGeometryCollection\n\n            if (value.geometries && Array.isArray(value.geometries)) {\n              var coordinateLength = value.geometries.length;\n              var subArrays = [geoBuff];\n\n              for (var _i3 = 0; _i3 < coordinateLength; _i3++) {\n                var tmpBuf = this.getBufferFromGeometryValue(value.geometries[_i3]);\n                if (tmpBuf == null) break;\n                subArrays.push(tmpBuf);\n              }\n\n              geoBuff.writeInt32LE(subArrays.length - 1, 5);\n              return Buffer.concat(subArrays);\n            } else {\n              geoBuff.writeInt32LE(0, 5);\n              return geoBuff;\n            }\n\n          default:\n            return null;\n        }\n\n        if (value.coordinates && Array.isArray(value.coordinates)) {\n          var _coordinateLength = value.coordinates.length;\n          var _subArrays = [geoBuff];\n\n          for (var _i4 = 0; _i4 < _coordinateLength; _i4++) {\n            var _tmpBuf = this.getBufferFromGeometryValue(value.coordinates[_i4], type);\n\n            if (_tmpBuf == null) break;\n\n            _subArrays.push(_tmpBuf);\n          }\n\n          geoBuff.writeInt32LE(_subArrays.length - 1, 5);\n          return Buffer.concat(_subArrays);\n        } else {\n          geoBuff.writeInt32LE(0, 5);\n          return geoBuff;\n        }\n      } else {\n        switch (headerType) {\n          case 'MultiPoint':\n            if (value && Array.isArray(value) && value.length >= 2 && !isNaN(value[0]) && !isNaN(value[1])) {\n              geoBuff = Buffer.allocUnsafe(21);\n              geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n\n              geoBuff.writeInt32LE(1, 1); //wkbPoint\n\n              geoBuff.writeDoubleLE(value[0], 5); //X\n\n              geoBuff.writeDoubleLE(value[1], 13); //Y\n\n              return geoBuff;\n            }\n\n            return null;\n\n          case 'MultiLineString':\n            if (value && Array.isArray(value)) {\n              var _pointNumber = value.length;\n              geoBuff = Buffer.allocUnsafe(9 + 16 * _pointNumber);\n              geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n\n              geoBuff.writeInt32LE(2, 1); //wkbLineString\n\n              geoBuff.writeInt32LE(_pointNumber, 5);\n\n              for (var _i5 = 0; _i5 < _pointNumber; _i5++) {\n                if (value[_i5] && Array.isArray(value[_i5]) && value[_i5].length >= 2 && !isNaN(value[_i5][0]) && !isNaN(value[_i5][1])) {\n                  geoBuff.writeDoubleLE(value[_i5][0], 9 + 16 * _i5); //X\n\n                  geoBuff.writeDoubleLE(value[_i5][1], 17 + 16 * _i5); //Y\n                } else {\n                  return null;\n                }\n              }\n\n              return geoBuff;\n            }\n\n            return null;\n\n          case 'MultiPolygon':\n            if (value && Array.isArray(value)) {\n              var _numRings = value.length;\n              var _size = 0;\n\n              for (var _i6 = 0; _i6 < _numRings; _i6++) {\n                _size += 4 + 16 * value[_i6].length;\n              }\n\n              geoBuff = Buffer.allocUnsafe(9 + _size);\n              geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n\n              geoBuff.writeInt32LE(3, 1); //wkbPolygon\n\n              geoBuff.writeInt32LE(_numRings, 5);\n              pos = 9;\n\n              for (var _i7 = 0; _i7 < _numRings; _i7++) {\n                var _lineString = value[_i7];\n\n                if (_lineString && Array.isArray(_lineString)) {\n                  geoBuff.writeInt32LE(_lineString.length, pos);\n                  pos += 4;\n\n                  for (var _j = 0; _j < _lineString.length; _j++) {\n                    if (_lineString[_j] && Array.isArray(_lineString[_j]) && _lineString[_j].length >= 2 && !isNaN(_lineString[_j][0]) && !isNaN(_lineString[_j][1])) {\n                      geoBuff.writeDoubleLE(_lineString[_j][0], pos); //X\n\n                      geoBuff.writeDoubleLE(_lineString[_j][1], pos + 8); //Y\n\n                      pos += 16;\n                    } else {\n                      return null;\n                    }\n                  }\n                }\n              }\n\n              return geoBuff;\n            }\n\n            return null;\n        }\n\n        return null;\n      }\n    }\n    /**\n     * Read text result-set row\n     *\n     * see: https://mariadb.com/kb/en/library/resultset-row/#text-resultset-row\n     * data are created according to their type.\n     *\n     * @param columns     columns metadata\n     * @param packet      current row packet\n     * @param connOpts    connection options\n     * @returns {*}       row data\n     */\n\n  }, {\n    key: \"parseRow\",\n    value: function parseRow(columns, packet, connOpts) {\n      throw new Error('not implemented');\n    }\n  }]);\n\n  return CommonBinary;\n}(ResultSet);\n\nmodule.exports = CommonBinary;","map":{"version":3,"sources":["C:/Users/dembr/Documents/GitHub/react_projects/react-urol-database/node_modules/mariadb/lib/cmd/common-binary-cmd.js"],"names":["ResultSet","require","CommonBinary","resolve","reject","cmdOpts","connOpts","sql","values","configAssign","initialValues","out","value","opts","info","flushed","writeInt8","writeLengthStringAscii","Object","prototype","toString","call","writeBinaryDate","Buffer","isBuffer","writeLengthEncodedBuffer","toSqlString","writeLengthEncodedString","String","type","includes","geoBuff","getBufferFromGeometryValue","concat","from","JSON","stringify","headerType","pos","allocUnsafe","writeInt32LE","coordinates","Array","isArray","length","isNaN","writeDoubleLE","pointNumber","i","numRings","size","lineString","j","geometries","coordinateLength","subArrays","tmpBuf","push","columns","packet","Error","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst ResultSet = require('./resultset');\n\nclass CommonBinary extends ResultSet {\n  constructor(resolve, reject, cmdOpts, connOpts, sql, values) {\n    super(resolve, reject);\n    this.configAssign(connOpts, cmdOpts);\n    this.sql = sql;\n    this.initialValues = values;\n  }\n\n  /**\n   * Write (and escape) current parameter value to output writer\n   *\n   * @param out     output writer\n   * @param value   current parameter\n   * @param opts    connection options\n   * @param info    connection information\n   */\n  writeParam(out, value, opts, info) {\n    let flushed = false;\n    switch (typeof value) {\n      case 'boolean':\n        flushed = out.writeInt8(0x00);\n        flushed = out.writeInt8(value ? 0x01 : 0x00) || flushed;\n        break;\n      case 'number':\n        flushed = out.writeInt8(0x00);\n        flushed = out.writeLengthStringAscii('' + value) || flushed;\n        break;\n      case 'object':\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          flushed = out.writeInt8(0x00);\n          flushed = out.writeBinaryDate(value, opts) || flushed;\n        } else if (Buffer.isBuffer(value)) {\n          flushed = out.writeInt8(0x00);\n          flushed = out.writeLengthEncodedBuffer(value) || flushed;\n        } else if (typeof value.toSqlString === 'function') {\n          flushed = out.writeInt8(0x00);\n          flushed = out.writeLengthEncodedString(String(value.toSqlString())) || flushed;\n        } else {\n          if (\n            value.type != null &&\n            [\n              'Point',\n              'LineString',\n              'Polygon',\n              'MultiPoint',\n              'MultiLineString',\n              'MultiPolygon',\n              'GeometryCollection'\n            ].includes(value.type)\n          ) {\n            const geoBuff = this.getBufferFromGeometryValue(value);\n            if (geoBuff) {\n              flushed = out.writeInt8(0x00); //Value follow\n              flushed =\n                out.writeLengthEncodedBuffer(Buffer.concat([Buffer.from([0, 0, 0, 0]), geoBuff])) ||\n                flushed;\n            } else {\n              flushed = out.writeInt8(0x01); //NULL\n            }\n          } else {\n            //TODO check if permitSetMultiParamEntries is needed !?\n            flushed = out.writeInt8(0x00);\n            flushed = out.writeLengthEncodedString(JSON.stringify(value)) || flushed;\n          }\n        }\n        break;\n      default:\n        flushed = out.writeInt8(0x00);\n        flushed = out.writeLengthEncodedString(value) || flushed;\n    }\n    return flushed;\n  }\n\n  getBufferFromGeometryValue(value, headerType) {\n    let geoBuff;\n    let pos;\n    let type;\n    if (!headerType) {\n      switch (value.type) {\n        case 'Point':\n          geoBuff = Buffer.allocUnsafe(21);\n          geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n          geoBuff.writeInt32LE(1, 1); //wkbPoint\n          if (\n            value.coordinates &&\n            Array.isArray(value.coordinates) &&\n            value.coordinates.length >= 2 &&\n            !isNaN(value.coordinates[0]) &&\n            !isNaN(value.coordinates[1])\n          ) {\n            geoBuff.writeDoubleLE(value.coordinates[0], 5); //X\n            geoBuff.writeDoubleLE(value.coordinates[1], 13); //Y\n            return geoBuff;\n          } else {\n            return null;\n          }\n\n        case 'LineString':\n          if (value.coordinates && Array.isArray(value.coordinates)) {\n            const pointNumber = value.coordinates.length;\n            geoBuff = Buffer.allocUnsafe(9 + 16 * pointNumber);\n            geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n            geoBuff.writeInt32LE(2, 1); //wkbLineString\n            geoBuff.writeInt32LE(pointNumber, 5);\n            for (let i = 0; i < pointNumber; i++) {\n              if (\n                value.coordinates[i] &&\n                Array.isArray(value.coordinates[i]) &&\n                value.coordinates[i].length >= 2 &&\n                !isNaN(value.coordinates[i][0]) &&\n                !isNaN(value.coordinates[i][1])\n              ) {\n                geoBuff.writeDoubleLE(value.coordinates[i][0], 9 + 16 * i); //X\n                geoBuff.writeDoubleLE(value.coordinates[i][1], 17 + 16 * i); //Y\n              } else {\n                return null;\n              }\n            }\n            return geoBuff;\n          } else {\n            return null;\n          }\n\n        case 'Polygon':\n          if (value.coordinates && Array.isArray(value.coordinates)) {\n            const numRings = value.coordinates.length;\n            let size = 0;\n            for (let i = 0; i < numRings; i++) {\n              size += 4 + 16 * value.coordinates[i].length;\n            }\n            geoBuff = Buffer.allocUnsafe(9 + size);\n            geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n            geoBuff.writeInt32LE(3, 1); //wkbPolygon\n            geoBuff.writeInt32LE(numRings, 5);\n            pos = 9;\n            for (let i = 0; i < numRings; i++) {\n              const lineString = value.coordinates[i];\n              if (lineString && Array.isArray(lineString)) {\n                geoBuff.writeInt32LE(lineString.length, pos);\n                pos += 4;\n                for (let j = 0; j < lineString.length; j++) {\n                  if (\n                    lineString[j] &&\n                    Array.isArray(lineString[j]) &&\n                    lineString[j].length >= 2 &&\n                    !isNaN(lineString[j][0]) &&\n                    !isNaN(lineString[j][1])\n                  ) {\n                    geoBuff.writeDoubleLE(lineString[j][0], pos); //X\n                    geoBuff.writeDoubleLE(lineString[j][1], pos + 8); //Y\n                    pos += 16;\n                  } else {\n                    return null;\n                  }\n                }\n              }\n            }\n            return geoBuff;\n          } else {\n            return null;\n          }\n\n        case 'MultiPoint':\n          type = 'MultiPoint';\n          geoBuff = Buffer.allocUnsafe(9);\n          geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n          geoBuff.writeInt32LE(4, 1); //wkbMultiPoint\n          break;\n\n        case 'MultiLineString':\n          type = 'MultiLineString';\n          geoBuff = Buffer.allocUnsafe(9);\n          geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n          geoBuff.writeInt32LE(5, 1); //wkbMultiLineString\n          break;\n\n        case 'MultiPolygon':\n          type = 'MultiPolygon';\n          geoBuff = Buffer.allocUnsafe(9);\n          geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n          geoBuff.writeInt32LE(6, 1); //wkbMultiPolygon\n          break;\n\n        case 'GeometryCollection':\n          geoBuff = Buffer.allocUnsafe(9);\n          geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n          geoBuff.writeInt32LE(7, 1); //wkbGeometryCollection\n\n          if (value.geometries && Array.isArray(value.geometries)) {\n            const coordinateLength = value.geometries.length;\n            const subArrays = [geoBuff];\n            for (let i = 0; i < coordinateLength; i++) {\n              const tmpBuf = this.getBufferFromGeometryValue(value.geometries[i]);\n              if (tmpBuf == null) break;\n              subArrays.push(tmpBuf);\n            }\n            geoBuff.writeInt32LE(subArrays.length - 1, 5);\n            return Buffer.concat(subArrays);\n          } else {\n            geoBuff.writeInt32LE(0, 5);\n            return geoBuff;\n          }\n        default:\n          return null;\n      }\n      if (value.coordinates && Array.isArray(value.coordinates)) {\n        const coordinateLength = value.coordinates.length;\n        const subArrays = [geoBuff];\n        for (let i = 0; i < coordinateLength; i++) {\n          const tmpBuf = this.getBufferFromGeometryValue(value.coordinates[i], type);\n          if (tmpBuf == null) break;\n          subArrays.push(tmpBuf);\n        }\n        geoBuff.writeInt32LE(subArrays.length - 1, 5);\n        return Buffer.concat(subArrays);\n      } else {\n        geoBuff.writeInt32LE(0, 5);\n        return geoBuff;\n      }\n    } else {\n      switch (headerType) {\n        case 'MultiPoint':\n          if (\n            value &&\n            Array.isArray(value) &&\n            value.length >= 2 &&\n            !isNaN(value[0]) &&\n            !isNaN(value[1])\n          ) {\n            geoBuff = Buffer.allocUnsafe(21);\n            geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n            geoBuff.writeInt32LE(1, 1); //wkbPoint\n            geoBuff.writeDoubleLE(value[0], 5); //X\n            geoBuff.writeDoubleLE(value[1], 13); //Y\n            return geoBuff;\n          }\n          return null;\n\n        case 'MultiLineString':\n          if (value && Array.isArray(value)) {\n            const pointNumber = value.length;\n            geoBuff = Buffer.allocUnsafe(9 + 16 * pointNumber);\n            geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n            geoBuff.writeInt32LE(2, 1); //wkbLineString\n            geoBuff.writeInt32LE(pointNumber, 5);\n            for (let i = 0; i < pointNumber; i++) {\n              if (\n                value[i] &&\n                Array.isArray(value[i]) &&\n                value[i].length >= 2 &&\n                !isNaN(value[i][0]) &&\n                !isNaN(value[i][1])\n              ) {\n                geoBuff.writeDoubleLE(value[i][0], 9 + 16 * i); //X\n                geoBuff.writeDoubleLE(value[i][1], 17 + 16 * i); //Y\n              } else {\n                return null;\n              }\n            }\n            return geoBuff;\n          }\n          return null;\n\n        case 'MultiPolygon':\n          if (value && Array.isArray(value)) {\n            const numRings = value.length;\n            let size = 0;\n            for (let i = 0; i < numRings; i++) {\n              size += 4 + 16 * value[i].length;\n            }\n            geoBuff = Buffer.allocUnsafe(9 + size);\n            geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n            geoBuff.writeInt32LE(3, 1); //wkbPolygon\n            geoBuff.writeInt32LE(numRings, 5);\n            pos = 9;\n            for (let i = 0; i < numRings; i++) {\n              const lineString = value[i];\n              if (lineString && Array.isArray(lineString)) {\n                geoBuff.writeInt32LE(lineString.length, pos);\n                pos += 4;\n                for (let j = 0; j < lineString.length; j++) {\n                  if (\n                    lineString[j] &&\n                    Array.isArray(lineString[j]) &&\n                    lineString[j].length >= 2 &&\n                    !isNaN(lineString[j][0]) &&\n                    !isNaN(lineString[j][1])\n                  ) {\n                    geoBuff.writeDoubleLE(lineString[j][0], pos); //X\n                    geoBuff.writeDoubleLE(lineString[j][1], pos + 8); //Y\n                    pos += 16;\n                  } else {\n                    return null;\n                  }\n                }\n              }\n            }\n            return geoBuff;\n          }\n          return null;\n      }\n      return null;\n    }\n  }\n\n  /**\n   * Read text result-set row\n   *\n   * see: https://mariadb.com/kb/en/library/resultset-row/#text-resultset-row\n   * data are created according to their type.\n   *\n   * @param columns     columns metadata\n   * @param packet      current row packet\n   * @param connOpts    connection options\n   * @returns {*}       row data\n   */\n  parseRow(columns, packet, connOpts) {\n    throw new Error('not implemented');\n  }\n}\n\nmodule.exports = CommonBinary;\n"]},"metadata":{},"sourceType":"script"}